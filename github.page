---
title: GitHub 設定指引
toc: no
...

(以下內容由 `許元杰<https://github.com/Jayjack0116>`_ 貢獻)

建立 GitHub 帳號
------------------------
* Github 是個 Git 的托管網站，可讓開發者將自己的專案儲存到網路上，與全世界分享，我們可方便的使用 Git 在本機進行專案管理。
* GitHub 同時提供付費帳號和為了開放原始碼程式提供的免費帳號。根據 2009 年的 Git 使用者調查，GitHub 是最熱門的 Git 分享網站。它提供了如 feeds、followers 和顯示開發者們如何在他們版本庫上的版本工作的圖表。 GitHub 也提供類似剪貼簿的功能，issue tracker 和網頁使用 Wiki，通過一個 git repository 即可對這些頁面進行編輯。

.. image:: /use-git-01.png

　

建立新 repository
------------------------
在和本機的 repository 連動之前，先給自己的專案取個名字吧，這會是你專案之後的名字，也會是其他人搜尋你專案的時候的關鍵字，好的專案一定有一個好的名字。

.. image:: /use-git-02.png

上圖是筆者新增一個叫做 "Embedded-System-Class" 的 repository，以及 Fork 課程所用的 `embedded2015/arm-lecture<https://github.com/embedded2015/arm-lecture/>`_ 這個 repository。

　

綁訂機器的 SSH key
---------------------------
因為要讓 Github 知道是我們這台電腦上傳的專案，所以我們要和 Github 之間建立一種默契，這個默契就是使用 ssh 協定時的 `public key<http://en.wikipedia.org/wiki/Public-key_cryptography>`_，我們給 Github 我們本機的 ssh public key ，告訴 Github 拿著這個 key 的電腦才是這個帳號的使用者， 如此一來就只能由這台電腦進行管理，才不會造成其他人來我們的帳號亂上傳東西的窘境。

首先，點選右上角的工具按鈕，進入帳號設定頁面，在頁面的左下角點選 "SSH keys"

.. image:: /use-git-03.png

　

SSH key 產生的方法
---------------------------

(``$`` 開頭的表示法，就是說明在 Linux 終端機輸入指令)

　

1. 輸入指令

.. code-block:: prettyprint

    $ ssh-keygen -t rsa -C "your_email@example.com"

後面那是自己申請 Github 所使用的信箱。之後 ssh 程式會要求輸入 passphrase：

.. image:: /use-git-04.png

　

2. 直接按下 Enter 鍵即可。

.. image:: /use-git-05.png

　

3. 輸入一個passphrase，如不想輸入直接按下 Enter 鍵即可。

.. image:: /use-git-06.jpg

　

4. 此時顯示的是你SSH Key的fingerprint

.. image:: /use-git-07.jpg

　

5. 將剛剛產生的key加入ssh-agent中

如果你已安裝了 `Windows版的Github<https://windows.github.com/>`_ ，你可以在不使用SSH Key的狀況下執行clone等操作。windows版本同時支援許多Git Bash tool，可運行眾多的Git指令。

    5-1. 如果你已安裝Git Bash，輸入以下指令以啟動ssh-agent

    .. image:: /use-git-08.jpg

    　　如果你使用的是 `msysgit<https://msysgit.github.io/>`_ 等軟體，則輸入以下指令

    .. image:: /use-git-09.jpg

　

    5-2. 將剛剛產生的key加入ssh-agent中

    .. image:: /use-git-10.jpg

　

6. 到Github網站加入你的SSH KEY

將SSH Key複製到你的剪貼簿，如果你的Key檔案名稱為id_dsa.pub、id_ecdsa.pub orid_ed25519.pub等，請自行將以下程式碼中「id_rsa.pub」修改成你的檔案名稱。

.. image:: /use-git-11.jpg

　

    6-1. 點選工具 icon

    .. image:: /use-git-12.jpg

　

    6-2. 點選SSH Keys

    .. image:: /use-git-13.jpg

　

    6-3. 選擇 Add SSH key

    .. image:: /use-git-14.jpg

　

    6-4. 貼上key!!!!

    .. image:: /use-git-15.jpg

　

    6-5. 按下 Add key就完成啦!

　

7. 驗證你有沒有綁訂了

　

    7-1. 輸入 $ ssh -T git@github.com

    .. image:: /use-git-16.jpg

　

    7-2. 你會看到這個 warning，然後輸入"yes"

    .. image:: /use-git-17.jpg

　

    7-3. 你將會看到

    .. image:: /use-git-18.jpg

    　　這樣就成功囉!

　

同步
------------------------
將本機repository 和 Github repository 同步

打開空的 repository，Github 會指示你如何將本機 repository remote 到 Git 的 repository 進入到本機的 repository 資料夾之中，並輸入以下指令，即可連線並把目前的 repository 同步到 Github 上面了。

.. code-block:: prettyprint

    $ git remote add origin git@github.com:your_account/your_repository.git

.. code-block:: prettyprint

    $ git push -u origin master

之後只需要輸入

.. code-block:: prettyprint

    $ git push

即可

　

Fork其他使用者的專案
------------------------
Fork 是一個較為特殊的稱呼方式，意思是將其他使用者的 repository 複製到本機，我也可以直接透過他的 repository 來自己修改這個專案，讓這個專案更好。
如果你有寫入權限的話(被加入成Collaborators)，就可以用 SSH 協定 Clone 下來：

.. code-block:: prettyprint

    $ git clone git@github.com:Username/repository.git

如果沒有寫入權限 (Collaborators)的話，因為這個專案是公開的，所以你還是可以用 Git 協定 Clone 下來：

.. code-block:: prettyprint

    $ git clone git://github.com/Username/repository.git

如果有防火牆問題，改用 HTTPS 協定：

.. code-block:: prettyprint

    $ git clone https://github.com/Username/repository.git

　

Pull - 從遠端更新
------------------------
.. code-block:: prettyprint

    $ git pull 或 git pull origin master

實際作用是先 git fetch 遠端的 branch，然後與本地端的 branch 做 merge，產生一個 merge commit 節點

　

Push - 將 Commit 送出去
------------------------
.. code-block:: prettyprint

    $ git push 或 git push origin master
實際的作用是將本地端的 master branch 與遠端的 master branch 作 fast-forward 合併。如果出現 [rejected] 錯誤的話，表示你必須先作 pull。

　

如果想要熟悉Git指令的話......
------------------------
以下是以GUI方式呈現指令所產生結果的網站:

`LearnGitBranching<http://pcottle.github.io/learnGitBranching/>`_

`Visualizing Git Concepts with D3<http://onlywei.github.io/explain-git-with-d3/>`_

　

RISC
------------------------
Reduced instruction set computing簡稱RISC(發音'risk')，是一種CPU設計模式，對指令數目和定址方式都做了精簡，指令並列執行程度更好，編譯器的效率更高。
為什麼要設計RISC呢?請看下列故事:

在早期的電腦業界，`編譯器<http://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8>`_技術並不發達，程式多半以 machine code 或 assembly language 完成的。為了便於編寫程式，電腦架構師設計出越來越複雜的指令，可以直接對應高階程式語言的高階功能。當時的看法是硬體比編譯器更容易設計，所以結構的複雜性在硬體這端。
加速這種複雜化的另一因素是**缺乏大容量的記憶體**。在記憶體容量受限的應用中，具有極高訊息密度的程式更加實用。當時記憶體中的每一個位元組都很寶貴，例如只有幾千個位元組來儲存某個完整系統。它使產業界傾向於高度編碼的指令、長度不等的指令、多運算元的指令，以及把資料的搬移與計算合併在一起的指令。在當時看來，相對於使指令更容易解碼，指令的編碼打包問題尤為重要。

還有一個因素是當時的記憶體不僅容量少，而且速度很慢，使用的都是磁性技術。憑藉高密度打包的指令，存取慢速資源的頻率可以降低。
微處理器只有少量暫存器的兩個原因是：

* 暫存器每一個位元位都比外部記憶體貴。以當時的積體電路技術水準，大量暫存器對晶片或電路板而言是難以承受的。

* 一旦具有大數量的暫存器，相關的指令字（opcode）將會需要更多的位元位（使用寶貴的`RAM<http://zh.wikipedia.org/wiki/%E9%9A%A8%E6%A9%9F%E5%AD%98%E5%8F%96%E8%A8%98%E6%86%B6%E9%AB%94>`_）來定位暫存器。

基於上述原因，微處理器設計師儘可能使指令做更多的工作。這導致單個指令做全部的工作: 讀入兩個加數，相加，並將計算結果直接寫入記憶體；另一個例子是從記憶體讀取兩個數據，但計算結果儲存在暫存器內；第三個例子是從記憶體和暫存器各讀取一個數據，其結果再次寫入記憶體；以此類推。這種微處理器設計原理，在精簡指令集（RISC）的思路出現後，最終被人稱為複雜指令集(CISC)。
當時設計的一個通常目標是為每個指令都提供所有的尋址模式，稱為「正交性」。這給微處理器增加了一些複雜性，但理論上每個可能的命令均可單獨調整。相對於使用更簡單的指令，這樣做能夠使設計速度更快。

"Reduced"在RISC的意涵其實是可以比起以往的CPU設計架構用更少的cycle去完成一件工作或指令，而不是因為指令減少而因此用"Reduced"這個字眼，事實上，近幾年RISC的size有增加，像是 PowerPC 微處理器的RISC指令集和CISC IBM System/370的差不多大。

　

RISC 典型特色
------------------------

* Uniform instruction format, **using a single word with the opcode** in the same bit positions in every instruction, demanding less decoding

* Identical general purpose registers, **allowing any register to be used in any context**, simplifying compiler design (although normally there are separate floating point registers)

* Simple addressing modes, with complex addressing performed via **sequences of arithmetic, load-store operations**, or both

* Few data types in hardware, some CISCs have byte string instructions, or support complex numbers; this is so far unlikely to be found on a RISC.

* Processor throughput of **one instruction per cycle on average**

　

ARM Extra Features
---------------------------
* Variable cycle instructions (LD/STR multiple)

* Inline barrel shifter

* 16-bit (Thumb) and 32-bit instruction sets combined called Thumb2

* Conditional execution (reduces number of branches)

* Auto-increment/decrement addressing modes

* Changed to a Modified Harvard architecture since ARM9 (ARMv5)

* Extensions (not covered in this course):

    * TrustZone

    * VFP, NEON & SIMD (DSP & Multimedia processing)