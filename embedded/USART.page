INTRODUCTION
...................
The universal synchronous asynchronous receiver transmitter (USART) offers a flexible means of full-duplex data exchange with external equipment requiring an industry standard NRZ asynchronous serial data format. The USART offers a very wide range of baud rates using a fractional baud rate generator.

It supports synchronous one-way communication and half-duplex single wire
communication. It also supports the LIN (local interconnection network), Smartcard Protocol and IrDA (infrared data association) SIR ENDEC specifications, and modem operations (CTS/RTS). It allows multiprocessor communication.

High speed data communication is possible by using the DMA for multibuffer configuration.

MAIN FEATURES
...................

- Full duplex, asynchronous communications

- NRZ standard format (Mark/Space)

- Configurable oversampling method by 16 or by 8 to give flexibility between speed  and clock tolerance

- Fractional baud rate generator systems

 - Common programmable transmit and receive baud rate (refer to the datasheets for the value of the baud rate at the maximum APB frequency).

- Programmable data word length (8 or 9 bits)

- Configurable stop bits - support for 1 or 2 stop bits

- LIN Master Synchronous Break send capability and LIN slave break detection capability

 –  13-bit break generation and 10/11 bit break detection when USART is hardware configured for LIN

- Transmitter clock output for synchronous transmission

- IrDA SIR encoder decoder

 – Support for 3/16 bit duration for normal mode

- Smartcard emulation capability

 – The Smartcard interface supports the asynchronous protocol Smartcards as defined in the ISO 7816-3 standards

 – 0.5, 1.5 stop bits for Smartcard operation

- Single-wire half-duplex communication

- Configurable multibuffer communication using DMA (direct memory access)

 – Buffering of received/transmitted bytes in reserved SRAM using centralized DMA

- Separate enable bits for transmitter and receiver

- Transfer detection flags:

 – Receive buffer full

 – Transmit buffer empty

 – End of transmission flags

- Parity control:

 – Transmits parity bit

 – Checks parity of received data byte

- Four error detection flags:

 – Overrun error

 – Noise detection

 – Frame error

 – Parity error

- Ten interrupt sources with flags:

 – CTS changes

 – LIN break detection

 – Transmit data register empty

 – Transmission complete

 – Receive data register full

 – Idle line received

 – Overrun error

 – Framing error

 – Noise error

 – Parity error

- Multiprocessor communication - enter into mute mode if address match does not occur

- Wake up from mute mode (by idle line detection or address mark detection)

- Two receiver wakeup modes: Address bit (MSB, 9th bit), Idle line


USART functional description
.................................


USART BLOCK DIAGRAM
======================================
.. image:: /usart_block_diagram.png



USART character description
======================================
Word length may be selected as being either 8 or 9 bits by programming the M bit in the
USART_CR1 register (see Figure 246).

The TX pin is in low state during the start bit. It is in high state during the stop bit.
An Idle character is interpreted as an entire frame of “1”s followed by the start bit of the next
frame which contains data (The number of “1” ‘s will include the number of stop bits).
A Break character is interpreted on receiving “0”s for a frame period. At the end of the
break frame the transmitter inserts either 1 or 2 stop bits (logic “1” bit) to acknowledge the
start bit.

Transmission and reception are driven by a common baud rate generator, the clock for each
is generated when the enable bit is set respectively for the transmitter and receiver.
The details of each block is given below.

.. image:: /idleandbreak.png


Transmitter
============================
The transmitter can send data words of either 8 or 9 bits depending on the M bit status.
When the transmit enable bit (TE) is set, the data in the transmit shift register is output on
the TX pin and the corresponding clock pulses are output on the SCLK pin.


Character transmission
------------------------------------
During an USART transmission, data shifts out least significant bit first on the TX pin. In this
mode, the USART_DR register consists of a buffer (TDR) between the internal bus and the
transmit shift register (see Figure 245).

Every character is preceded by a start bit which is a logic level low for one bit period. The
character is terminated by a configurable number of stop bits.

The following stop bits are supported by USART: 0.5, 1, 1.5 and 2 stop bits.


Receiver
====================================
The USART can receive data words of either 8 or 9 bits depending on the M bit in the
USART_CR1 register.



Break character
====================================
When a break character is received, the USART handles it as a framing error.


Idle character
====================================
When an idle frame is detected, there is the same procedure as a data received character
plus an interrupt if the IDLEIE bit is set.


Overrun error
====================================
An overrun error occurs when a character is received when RXNE has not been reset. Data
can not be transferred from the shift register to the RDR register until the RXNE bit is
cleared.

The RXNE flag is set after every byte received. An overrun error occurs if RXNE flag is set
when the next data is received or the previous DMA request has not been serviced. When
an overrun error occurs:

● The ORE bit is set.

● The RDR content will not be lost. The previous data is available when a read to
USART_DR is performed.

● The shift register will be overwritten. After that point, any data received during overrun
is lost.

● An interrupt is generated if either the RXNEIE bit is set or both the EIE and DMAR bits
are set.

● The ORE bit is reset by a read to the USART_SR register followed by a USART_DR
register read operation.

Note: The ORE bit, when set, indicates that at least 1 data has been lost. There are two
possibilities:

● if RXNE=1, then the last valid data is stored in the receive register RDR and can be
read,

● if RXNE=0, then it means that the last valid data has already been read and thus there
is nothing to be read in the RDR. This case can occur when the last valid data is read in
the RDR at the same time as the new (and lost) data is received. It may also occur
when the new data is received during the reading sequence (between the USART_SR
register read access and the USART_DR read access).

IrDA low-power mode 
............................

Transmitter:
========================
In low-power mode the pulse width is not maintained at 3/16 of the bit period. Instead, the 
width of the pulse is 3 times the low-power baud rate which can be a minimum of 1.42 MHz. 
Generally this value is 1.8432 MHz (1.42 MHz < PSC< 2.12 MHz). A low-power mode 
programmable divisor divides the system clock to achieve this value.


Receiver:
============================
Receiving in low-power mode is similar to receiving in normal mode. For glitch detection the 
USART should discard pulses of duration shorter than 1/PSC. A valid low is accepted only if 
its duration is greater than 2 periods of the IrDA low-power Baud clock (PSC value in 
USART_GTPR).


.. image:: /irda.PNG

.. image:: /normal_mode.PNG



USART SYNCHRONOUS MODE
......................
The synchronous mode is selected by writing the CLKEN bit in the USART_CR2 register to

1. In synchronous mode, the following bits must be kept cleared:

● LINEN bit in the USART_CR2 register,

● SCEN, HDSEL and IREN bits in the USART_CR3 register.

The SCLK pin works in conjunction with the TX pin. Thus, the clock is provided only if the transmitter is enabled (TE=1) and a data is being transmitted (the data register USART_DR has been written). This means that it is not possible to receive a synchronous data without transmitting data.

The LBCL, CPOL and CPHA bits have to be selected when both the transmitter and the
receiver are disabled (TE=RE=0) to ensure that the clock pulses function correctly. These bits should not be changed while the transmitter or the receiver is enabled.

.. image:: /synchronous_transmission.png


HARDWARE FLOW CONTROL
......................
It is possible to control the serial data flow between 2 devices by using the nCTS input and the nRTS output.

.. image:: /hardware_control_2usarts.png


RTS Flow Control
========================
If the RTS flow control is enabled (RTSE=1), then nRTS is asserted (tied low) as long as the USART receiver is ready to receive a new data. When the receive register is full, nRTS is deasserted, indicating that the transmission is expected to stop at the end of the current frame.

.. image:: /rst_flow_control.png


CTS Flow Control
========================
If the CTS flow control is enabled (CTSE=1), then the transmitter checks the nCTS input before transmitting the next frame. If nCTS is asserted (tied low), then the next data is transmitted (assuming that a data is to be transmitted, in other words, if TXE=0), else the transmission does not occur. When nCTS is deasserted during a transmission, the current transmission is completed before the transmitter stops.

When CTSE=1, the CTSIF status bit is automatically set by hardware as soon as the nCTS input toggles. It indicates when the receiver becomes ready or not ready for communication. An interrupt is generated if the CTSIE bit in the USART_CR3 register is set. The figure below shows an example of communication with CTS flow control enabled.

.. image:: /cst_flow_control.png


PARITY CONTROL
..............
Parity control (generation of parity bit in transmission and parity checking in reception) can be enabled by setting the PCE bit in the USART_CR1 register. Depending on the frame length defined by the M bit, the possible USART frame formats are as listed in Table 118.

.. image:: /frame_formats.png


Even parity
=====================
The parity bit is calculated to obtain an even number of “1s” inside the frame made of the 7 or 8 LSB bits (depending on whether M is equal to 0 or 1) and the parity bit.

E.g.: data=00110101; 4 bits set => parity bit will be 0 if even parity is selected (PS bit in USART_CR1 = 0).


Odd parity
=============
The parity bit is calculated to obtain an odd number of “1s” inside the frame made of the 7 or 8 LSB bits (depending on whether M is equal to 0 or 1) and the parity bit.

E.g.: data=00110101; 4 bits set => parity bit will be 1 if odd parity is selected (PS bit in USART_CR1 = 1).


Parity checking in reception
=========================================
If the parity check fails, the PE flag is set in the USART_SR register and an interrupt is generated if PEIE is set in the USART_CR1 register. The PE flag is cleared by a software sequence (a read from the status register followed by a read or write access to the USART_DR data register).


Parity generation in transmission
======================================
If the PCE bit is set in USART_CR1, then the MSB bit of the data written in the data register is transmitted but is changed by the parity bit (even number of “1s” if even parity is selected (PS=0) or an odd number of “1s” if odd parity is selected (PS=1)).

CODE SECTION
...................

REFERENCE
..................