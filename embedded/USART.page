INTRODUCTION
...................
The universal synchronous asynchronous receiver transmitter (USART) offers a flexible means of full-duplex data exchange with external equipment requiring an industry standard NRZ asynchronous serial data format. The USART offers a very wide range of baud rates using a fractional baud rate generator.

It supports synchronous one-way communication and half-duplex single wire
communication. It also supports the LIN (local interconnection network), Smartcard Protocol and IrDA (infrared data association) SIR ENDEC specifications, and modem operations (CTS/RTS). It allows multiprocessor communication.

High speed data communication is possible by using the DMA for multibuffer configuration.

MAIN FEATURES
...................

- Full duplex, asynchronous communications

- NRZ standard format (Mark/Space)

- Configurable oversampling method by 16 or by 8 to give flexibility between speed  and clock tolerance

- Fractional baud rate generator systems

 - Common programmable transmit and receive baud rate (refer to the datasheets for the value of the baud rate at the maximum APB frequency).

- Programmable data word length (8 or 9 bits)

- Configurable stop bits - support for 1 or 2 stop bits

- LIN Master Synchronous Break send capability and LIN slave break detection capability

 –  13-bit break generation and 10/11 bit break detection when USART is hardware configured for LIN

- Transmitter clock output for synchronous transmission

- IrDA SIR encoder decoder

 – Support for 3/16 bit duration for normal mode

- Smartcard emulation capability

 – The Smartcard interface supports the asynchronous protocol Smartcards as defined in the ISO 7816-3 standards

 – 0.5, 1.5 stop bits for Smartcard operation

- Single-wire half-duplex communication

- Configurable multibuffer communication using DMA (direct memory access)

 – Buffering of received/transmitted bytes in reserved SRAM using centralized DMA

- Separate enable bits for transmitter and receiver

- Transfer detection flags:

 – Receive buffer full

 – Transmit buffer empty

 – End of transmission flags

- Parity control:

 – Transmits parity bit

 – Checks parity of received data byte

- Four error detection flags:

 – Overrun error

 – Noise detection

 – Frame error

 – Parity error

- Ten interrupt sources with flags:

 – CTS changes

 – LIN break detection

 – Transmit data register empty

 – Transmission complete

 – Receive data register full

 – Idle line received

 – Overrun error

 – Framing error

 – Noise error

 – Parity error

- Multiprocessor communication - enter into mute mode if address match does not occur

- Wake up from mute mode (by idle line detection or address mark detection)

- Two receiver wakeup modes: Address bit (MSB, 9th bit), Idle line

USART BLOCK DIAGRAM
.....................
.. image:: /usart_block_diagram.png

USART SYNCHRONOUS MODE
......................
The synchronous mode is selected by writing the CLKEN bit in the USART_CR2 register to

1. In synchronous mode, the following bits must be kept cleared:

● LINEN bit in the USART_CR2 register,

● SCEN, HDSEL and IREN bits in the USART_CR3 register.

The SCLK pin works in conjunction with the TX pin. Thus, the clock is provided only if the transmitter is enabled (TE=1) and a data is being transmitted (the data register USART_DR has been written). This means that it is not possible to receive a synchronous data without transmitting data.

The LBCL, CPOL and CPHA bits have to be selected when both the transmitter and the
receiver are disabled (TE=RE=0) to ensure that the clock pulses function correctly. These bits should not be changed while the transmitter or the receiver is enabled.

.. image:: /synchronous_transmission.png


HARDWARE FLOW CONTROL
......................
It is possible to control the serial data flow between 2 devices by using the nCTS input and the nRTS output.

.. image:: /hardware_control_2usarts.png


RTS Flow Control
========================
If the RTS flow control is enabled (RTSE=1), then nRTS is asserted (tied low) as long as the USART receiver is ready to receive a new data. When the receive register is full, nRTS is deasserted, indicating that the transmission is expected to stop at the end of the current frame.

.. image:: /rst_flow_control.png


CTS Flow Control
========================
If the CTS flow control is enabled (CTSE=1), then the transmitter checks the nCTS input before transmitting the next frame. If nCTS is asserted (tied low), then the next data is transmitted (assuming that a data is to be transmitted, in other words, if TXE=0), else the transmission does not occur. When nCTS is deasserted during a transmission, the current transmission is completed before the transmitter stops.

When CTSE=1, the CTSIF status bit is automatically set by hardware as soon as the nCTS input toggles. It indicates when the receiver becomes ready or not ready for communication. An interrupt is generated if the CTSIE bit in the USART_CR3 register is set. The figure below shows an example of communication with CTS flow control enabled.

.. image:: /cst_flow_control.png


PARITY CONTROL
..............
Parity control (generation of parity bit in transmission and parity checking in reception) can be enabled by setting the PCE bit in the USART_CR1 register. Depending on the frame length defined by the M bit, the possible USART frame formats are as listed in Table 118.

.. image:: /frame_formats.png


Even parity
=====================
The parity bit is calculated to obtain an even number of “1s” inside the frame made of the 7 or 8 LSB bits (depending on whether M is equal to 0 or 1) and the parity bit.

E.g.: data=00110101; 4 bits set => parity bit will be 0 if even parity is selected (PS bit in USART_CR1 = 0).


Odd parity
=============
The parity bit is calculated to obtain an odd number of “1s” inside the frame made of the 7 or 8 LSB bits (depending on whether M is equal to 0 or 1) and the parity bit.

E.g.: data=00110101; 4 bits set => parity bit will be 1 if odd parity is selected (PS bit in USART_CR1 = 1).


Parity checking in reception
=========================================
If the parity check fails, the PE flag is set in the USART_SR register and an interrupt is generated if PEIE is set in the USART_CR1 register. The PE flag is cleared by a software sequence (a read from the status register followed by a read or write access to the USART_DR data register).


Parity generation in transmission
======================================
If the PCE bit is set in USART_CR1, then the MSB bit of the data written in the data register is transmitted but is changed by the parity bit (even number of “1s” if even parity is selected (PS=0) or an odd number of “1s” if odd parity is selected (PS=1)).

CODE SECTION
...................
main()
{
//初始化GPIO
GPIO_InitTypeDef GPIO_InitStructure;

GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;
GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
GPIO_Init(GPIOB, &GPIO_InitStructure);

GPIO_PinAFConfig(GPIOB, GPIO_PinSource6, GPIO_AF_USART1); 
GPIO_PinAFConfig(GPIOB, GPIO_PinSource7, GPIO_AF_USART1);

//初始化UART
SART_InitStructure.USART_BaudRate = 115200;//設定baudrate
USART_InitStructure.USART_WordLength = USART_WordLength_8b;//設定word長度為8位
USART_InitStructure.USART_StopBits = USART_StopBits_1;//1位停止字節
USART_InitStructure.USART_Parity = USART_Parity_No;//無奇偶檢驗
USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//無流量控制
USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;//開啟Rx接收和Tx發送功能

USART_Init(USART1, &USART_InitStructure);
USART_Cmd(USART1, ENABLE);//啟動usart1


while(1)
{
    while(i < 100){
	send_byte('G');
	i++;
     }
    while(USART_GetFlagStatus(USART1, USART_FLAG_RXNE) != RESET)//等到有data才變為RESET
	b = (USART_ReceiveData(USART1) & 0x7F);



}

}
void send_byte(uint8_t b)
{
	
	USART_SendData(USART1, b);

    while(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);//直到USART1是空
}

...................