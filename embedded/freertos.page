---
title: FreeRTOS
toc: no
...

組員
----
* 梁穎睿 / TheKK 
* 李奇霖 / Shinshipower
* 方威迪 / waynew30777 
* 陳盈伸 / shin21 

共筆
----
* `Link<https://hackpad.com/FreeRTOSV8.0.0-PU3awKuzHz6#:h=%3Chardware-interfacing%3E>`_

FreeRTOS架構
-----------

FreeRTOS是一個相對較小的應用程式。最小化的FreeRTOS核心僅包括3個（.c）文件和少數標頭檔，總共不到9000行程式碼，還包括了註解和空行。一個典型的編譯後（二進制）binary小於10KB。

FreeRTOS的程式碼可以分解為三個主要區塊：任務，通訊，和硬體界面。

* 任務：大約有一半的FreeRTOS的核心程式碼用來處理多數作業系統首要關注的問題：任務。任務是給定優先權的用戶定義的C函數。 task.c和task.h完成了所有有關創造，排程，和維護任務的繁重工作。

* 通訊：任務很重要，不過任務間可以互相通訊則更為重要！它給我們帶來FreeRTOS的第二項任務：通訊。大約40%的FreeRTOS核心程式碼是用來處理通訊的。 queue.c和queue.h是負責處理FreeRTOS的通訊的。任務和中斷使用隊列互相發送數據，並且使用semaphore和mutex來發送critical section的使用情況。

* 硬體界面：接近9000行的程式碼拼湊起基本的FreeRTOS，是和硬體無關的；相同的程式碼都能夠運行，大約有6%的FreeRTOS的核心代碼，在硬體無關的FreeRTOS核心與硬體相關的程式碼間扮演著墊片的角色。我們將在下個部分討論硬體相關的程式碼。

檔案內容
----

portmacro.h:

    定義了硬體相關變數，如資料形態定義，以及硬體相關的函式呼叫的名稱定義(以portXXXXX爲名)等，統一各平臺呼叫函式的

port.c:

    定義了包含和硬體相關的程式碼的實作

FreeRTOSConfig.h:

    包含Clock speed, heap size, mutexes等等都在此定義

命名規則
----

* 變數
    char類型：以 c 為字首

    short類型：以 s 為字首

    long類型：以 l 為字首

    float類型：以 f 為字首

    double類型：以 d 為字首

    Enum變數：以 e 為字首

    其他（如struct）：以 x 為字首

    pointer有一个額外的字首 p , 例如short類型的pointer字首為 ps

    unsigned類型的變數有一個額外的字首 u , 例如unsigned short類型的變數字首為 us 
    
* Functions
    文件内：以 prv 為字首
    API：以其return類型為字首，按照對變數的定義
    名字：以其所在的文件名開頭。如vTaskDelete即在Task.c文件中名稱


Task的狀態
----------

.. image:: /Task狀態.png


* Ready : 準備好要執行的狀態
* Running : 正在給CPU執行的狀態
* Block : 等待中的狀態
* Suspended :等待中的狀態

每一種狀態狀態FreeRTOS都會給予一個list儲存（除了runnning)



Ready list的資料形態
---------------------

FreeRTOS使用ready list去管理待準備好要執行的tasks，而ready list的資料儲存方式如下圖

.. image:: /freertos-figures-full-ready-list-2.png

* Context Switch 時選出下一個欲執行的task

 下面是在ready list中依照優先度選取執行目標的程式其中，FreeRTOS的優先度排序最小優先權爲0，數字越大則優先權越高

.. code-block:: c

    /* In file: Source/tasks.c */
    while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    {
        configASSERT( uxTopReadyPriority );
        --uxTopReadyPriority;
    }
    listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    
    /*In file: Source/include.h */
    #define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )
    {
        List_t * const pxConstList = ( pxList );
        /* Increment the index to the next item and return the item, ensuring */
        /* we don't return the marker used at the end of the list.  */
        ( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext; 
        if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )  \
        {
            ( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;
        }
        ( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;
    }

* 創造全新task

TCB的資料結構：

 .. code-block:: c

    typedef struct tskTaskControlBlock
    {

        volatile portSTACK_TYPE *pxTopOfStack;                  /* Points to the location of
                                                                                                   the last item placed on 
                                                                                                   the tasks stack.  THIS 
                                                                                                   MUST BE THE FIRST MEMBER 
                                                                                                   OF THE STRUCT. */

        xListItem    xGenericListItem;                          /* List item used to place 
                                                                                       the TCB in ready and 
                                                                                       blocked queues. */

        xListItem    xEventListItem;                            /* List item used to place 
                                                                                     the TCB in event lists.*/

        unsigned portBASE_TYPE uxPriority;                      /* The priority of the task
                                                                                               where 0 is the lowest 
                                                                                               priority. */

        portSTACK_TYPE *pxStack;                                /* Points to the start of
                                                                                          the stack. */

        signed char    pcTaskName[ configMAX_TASK_NAME_LEN ];   /* Descriptive name given 
                                                                                                                      to the task when created.
                                                                                                                      Facilitates debugging 
                                                                                                                      only. */

        #if ( portSTACK_GROWTH > 0 )
        portSTACK_TYPE *pxEndOfStack;                         /* Used for stack overflow 
                                                                                             checking on architectures
                                                                                             where the stack grows up
                                                                                             from low memory. */
        #endif

        #if ( configUSE_MUTEXES == 1 )
        unsigned portBASE_TYPE uxBasePriority;                /* The priority last 
                                                                                                 assigned to the task - 
                                                                                                 used by the priority 
                                                                                                 inheritance mechanism. */
      #endif

    } tskTCB;


pxTopOfStack , pxEndOfStack :紀錄Stack的大小

uxPriority , uxBasePriority ：紀錄優先權 ,而後者是紀錄原本的優先權（可能發生再Mutux)

xGenericListItem , xEventListItem : 當一個任務被放入到FreeRTOS的一個列表中 ，被插入pointer的地方

xTaskCreate()函數被呼叫的時候，一個任務被創建。 FreeRTOS為一個任務新分配一個TCB target，來記錄它的名稱，優先級，和其他細節，接著分配用戶請求的總的HeapStack（假設有足夠使用的記憶體）和在TCB的pxStack成員中記錄Stack的記憶體起點。


爲了讓排程方便，以及第一次出場的task所以創造新task時，stack中除了該有的資料外，還要加上“空的”register資料(第一次執行，理論不會有register資料)，讓新task就像是一般被context switch的task一樣按照對變數的定義下面是實作方式
 
.. code-block:: c

    StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void  *pvParameters )
    {
    
    /* Simulate the stack frame as it would be created by a context switch
        interrupt. */

        /* Offset added to account for the way the MCU uses the stack on entry/exit
        of interrupts, and to ensure alignment. */
        pxTopOfStack--;

        *pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
        pxTopOfStack--;
        *pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
        pxTopOfStack--;
        *pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */

        /* Save code space by skipping register initialisation. */
        pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
        *pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */

        /* A save method is being used that requires each task to maintain its
        own exec return value. */
        pxTopOfStack--;
        *pxTopOfStack = portINITIAL_EXEC_RETURN;

        pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */

        return pxTopOfStack;
    }

在TCB完成初始化後，要把該TCB接上其他相關的list結構，這個過程中必須暫時停止interrupts功能，以免在list還沒設定好前，被其他的task使用停止interrupt的實作，是將CPU中控制interrupt權限(0~255)的暫存器(basepri)內容設爲最高，此時將沒有任何interrupt可以被呼叫該處呼叫的函數名為ulPortSetInterruptMask()


而當ARM Cortex-M4處理器在task遇上中斷時，會將register之內容push上該task的stack的頂端，待下次運行時pop回去 以下是在 port.c裡的實作

 .. code-block:: c

    void xPortPendSVHandler( void )
    {	/* This is a naked function. */
        __asm volatile
        (
        "	mrs r0, psp							\n"
        "	isb									\n"
        "										\n"
        "	ldr	r3, pxCurrentTCBConst			\n" /* Get the location of the current TCB. */
        "	ldr	r2, [r3]						\n"
        "										\n"
        "	tst r14, #0x10						\n" /* Is the task using the FPU context?  If so, push high vfp registers. */
        "	it eq								\n"
        "	vstmdbeq r0!, {s16-s31}				\n"
        "										\n"
        "	stmdb r0!, {r4-r11, r14}			\n" /* Save the core registers. */
        "										\n"
        "	str r0, [r2]						\n" /* Save the new top of stack into the first member of the TCB. */
        "										\n"
        "	stmdb sp!, {r3}						\n"
        "	mov r0, %0 							\n"
        "	msr basepri, r0						\n"
        "	bl vTaskSwitchContext				\n"
        "	mov r0, #0							\n"
        "	msr basepri, r0						\n"
        "	ldmia sp!, {r3}						\n"
        "										\n"
        "	ldr r1, [r3]						\n" /* The first item in pxCurrentTCB is the task top of stack. */
        "	ldr r0, [r1]						\n"
        "										\n"
        "	ldmia r0!, {r4-r11, r14}			\n" /* Pop the core registers. */
        "										\n"
        "	tst r14, #0x10						\n" /* Is the task using the FPU context?  If so, pop the high vfp registers too. */
        "	it eq								\n"
        "	vldmiaeq r0!, {s16-s31}				\n"
        "										\n"
        "	msr psp, r0							\n"
        "	isb									\n"
        "										\n"
        #ifdef WORKAROUND_PMU_CM001 /* XMC4000 specific errata workaround. */
        	#if WORKAROUND_PMU_CM001 == 1
        "			push { r14 }				\n"
        "			pop { pc }					\n"
        	#endif
        #endif
        "										\n"
        "	bx r14								\n"
        "										\n"
        "	.align 2							\n"
        "pxCurrentTCBConst: .word pxCurrentTCB	\n"
        ::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
        );
}

Communication
----------------------

* Queue

  .. image:: /qu.png

使用Queue來傳送data（variable或是pointer，但是用deep copy一份到queue裡，而不是用pointer指向variable）
Queue的結構如下


 .. code-block:: c

    typedef struct QueueDefinition{

      signed char *pcHead;                    /* Points to the beginning of the queue 

                                                 storage area. */

      signed char *pcTail;                    /* Points to the byte at the end of the 

                                                 queue storage area. One more byte is 

                                                 allocated than necessary to store the 

                                               queue items; this is used as a marker. */

      signed char *pcWriteTo;                 /* Points to the free next place in the 

                                                 storage area. */

      signed char *pcReadFrom;                /* Points to the last place that a queued 

                                                 item was read from. */

      xList xTasksWaitingToSend;              /* List of tasks that are blocked waiting 

                                                 to post onto this queue.  Stored in 

                                                 priority order. */

      xList xTasksWaitingToReceive;           /* List of tasks that are blocked waiting 

                                                 to read from this queue. Stored in 

                                                 priority order. */

      volatile unsigned portBASE_TYPE uxMessagesWaiting;/* The number of items currently

                                                           in the queue. */

      unsigned portBASE_TYPE uxLength;                  /* The length of the queue 

                                                           defined as the number of 

                                                           items it will hold, not the 

                                                           number of bytes. */

      unsigned portBASE_TYPE uxItemSize;                /* The size of each items that 

                                                           the queue will hold. */

    } xQUEUE;

由於queue可以被許多個task進行write，一個queue可能有許多個task處於block的狀態以等待queue有空間放data，一旦queue有空位時，會在這些被block的task中挑出一個priority最高的task，將他解除block並且進行write，若這些task的priority都一樣高，那將會挑出等待最久的task
FreeRTOS也可使用Queue來實作Semaphores 和 Mutexes：

    Semaphores按照對變數的定義

    semaphore用來讓一個task喚醒喚醒(wake)另一個task做事，例如:producer和consumer

    Mutexes

    mutex用來對共享資源做互斥存取

* 實作semaphore

    N-element semaphore，只需同步uxMessagesWaiting，且只需關心有多少queue entries被佔用，其中uxItemSize為0，item和data copying是不需要的

        需要 ARM Cortex-M4F 特有的機制，才能實做 semaphore 嗎？若是，其機制為何？

    需要，在存取uxMessagesWaiting時必須一次只能一個task去做更改（進、出入critical section），要防止一次兩個task進入修改的機制如下：

 .. code-block:: c

    void vPortEnterCritical( void ) 

    { 

        portDISABLE_INTERRUPTS(); 

        uxCriticalNesting++; 

        __asm volatile( "dsb" ); 

        __asm volatile( "isb" ); 

    } 

    /*-----------------------------------------------------------*/ 

     

    void vPortExitCritical( void ) 

    { 

        configASSERT( uxCriticalNesting ); 

        uxCriticalNesting--; 

        if( uxCriticalNesting == 0 ) 

        { 

            portENABLE_INTERRUPTS(); 

        } 

    }

* 實作mutex

    因為pcHead和pcTail不需要，所以overloadind來達到較好的使用率：


 .. code-block:: c

        /* Effectively make a union out of the xQUEUE structure. */

        #define uxQueueType           pcHead

        #define pxMutexHolder         pcTail

    uxQueueType若為0，表示this queue is being used for a mutex
    pxMutexHolder用來實作priority inheritance

        mutex 和 semaphore 的差異，請參見這篇短文: http://embeddedgurus.com/barr-code/2008/01/rtos-myth-1-mutexes-and-semaphores-are-interchangeable/

    另外: http://embeddedgurus.com/barr-code/2008/03/rtos-myth-3-mutexes-are-needed-at-the-task-level/

    
Scheduling
----------------

* 基本概念

  .. image:: /suspending.gif

在一般非即時作業系統上，通常每個task都會分到相同的CPU使用時間，RTOS則不盡然，後續將提到相關資訊
除了由kernel要求task交出CPU控制權外，各task也能夠選擇自行交出CPU控制權，舉凡

    Delay( sleep ): 停止運行一段特定時間

    wait( block ): 等待取得某資源

    等待事件觸發(例如鍵盤輸入)

* RTOS tick


  .. image:: /TickISR.gif

    Idle Task正在運行

    發生tick時間，控制權轉給TickISR()

configTICK_RATE_HZ
vControlTask

* Starvation

FreeRTOS為MultiLevel Queue，若priority高的task霸佔CPU，對於priority較低的task則無法執行，便會發生Starvation(低優先權很長一段時間都無法獲得CPU執行)

Interrupt handler
------------------------
 
 or this reason, it is necessary to make interrupts handlers' execution as short as possible.
On way to achieve this goal consists in the creation of tasks waiting for an interrupt to occur with a semaphore, and let
this safer portion of code actually handle the interrupt.
An ISR “gives” a semaphore andunblock a 'Handler” task that is able to handler the ISR, making the ISR execution much shorter
>>External Interrupt(EXTI)

所有interrupt handler的排序和名稱定義(並非實作內容)放置在startup_stm32f429_439xx.s中，實作則需要在其他地方宣告

使用者可以定義的外部中斷觸發條件爲EXTI_Line0至EXTI_Line15，不過EXTI_Line10~15和EXTI_Line5~9被設定爲觸發同一外部中斷，實際上能夠定義的中斷處理只有EXTI_Line0, 1, 2, 3, 4, 5~9, 10~15，總計七個

EXTI使用前必須：

* 欲使用的GPIO之初始設定

* 和GPIO連接(作爲觸發來源)

* 設定EXTI

    *模式( Interrupt, Event )

    *被觸發的條件( Rising, Falling, Rising&falling )

    *LineCmd( 尚未查明 )

* 設定NVIC通道，權限

硬體驅動原理
------------------
* 以 `GPIO</embedded/GPIO>`_ 為例
  - 參考 STM32Cube_FW_F4_V1.1.0/Projects/STM32F429I-Discovery/Examples/GPIO/GPIO_EXTI/readme.txt


效能表現
--------
●context switch
(context switch係指程序A要交出CPU使用權給程序B時，將程序A當前的狀態和register內資料存放至記憶體內，將先前程序B的狀態從記憶體讀取至register內的過程)

我們想得知FreeRTOS的context switch時間，並想出一個測試方法：

.. image:: /embedded/test1contextSwitch.jpg
1. 首先創建task1和task2，其中task2的priority大於task1的priority。task2先執行時，馬上就進行vTaskDelay使task2移至block狀態1秒，這時就會發生context switch，換成task1執行，這1秒的時間，task1不斷的進行i++，直到1秒結束後，回到task2執行，再由task2印出i值，並把i重新設0，此為一個週期。此動作可得到i在一秒時可跑至多少，設一秒可跑至k值。

2. 設定一個task3其priority高於task2，讓task3執行vTaskDelay 300秒，當300秒結束後，會中斷task1所執行的i++。再由task3印出i值，設其為final_i，k值與final_i值的差額，即為context switch的總時間。

下圖為隨機挑出45個i值做成圖表，其中平均i值為：4280015

.. image:: /embedded/test2contextSwitch.jpg
接著我們測出的final_i值，平均為：3913853，故可得到 (4280015 - 3913853)/ 4280015 = 0.0855 (秒)

0.0855秒代表在300秒的測試內的所有context switch時間之總和

而因為一個週期（第一個步驟）會經過2個context switch（上圖），我們測300內共有600個context switch，故我們測出每個context switch約為：0.0855 / 600 = 142.5（us）
 
 
 
●interrupt latency

我們的架構為是手動設定一個external interrupt，發生在BUTTON_USER按下時，下面程式是我們的實作：

.. code-block:: c

    i = 0;
    while( STM_EVAL_PBGetState( BUTTON_USER ) ){
        i++;
    }


當BUTTON_USER按下後，會先執行i++直到interruptHandler處理interrupt，讀i值即可得知interrupt latency，而實作結果發現i依舊為0。

●IPC（Inter-Process Communication） throughput

●realtime capability

參考資料
--------
* `The Architecture of Open Source Applications: FreeRTOS<http://www.aosabook.org/en/freertos.html>`_
  - `簡體中文翻譯<http://www.ituring.com.cn/article/4063>`_

* `Study of an operating system: FreeRTOS</embedded/FreeRTOS_Melot.pdf>`_
* `FreeRTOS 即時核心實用指南</embedded/FreeRTOS-manual-zh.pdf>`_