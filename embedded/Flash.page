---
title: Flash
categories: STM32F4
...

1.Flash 簡介
============

1.1 簡介
-------------

- 記憶體RAM?ROM?
  - RAM:隨機存取記憶體(Random Access Memory)
    - 內部資料可以任意讀寫，用來存放由硬碟載入的程式或資料供CPU處理運算
    - EX:main memory
    - 分成DRAM、SRAM

  - ROM:唯讀記憶體(Read Only Memory)
    - 資料一但寫入就無法修改，除非透過特殊的方式(例如EPROM用紫外光照射)才能達成
    - 適合放重要且不能被刪除的資料
    - 細分為PROM、EPROM、EEPROM(EPROM的改良版)
    - EX:BIOS早期放在ROM中，但隨著BIOS大小和複雜程度增加，硬體更新的速度快，以至於BIOS也必須更新以支援新硬體，於是BIOS就改成存在EEPROM或快閃記憶體中讓使用者可以更新
    
- `EPROM:<http://zh.wikipedia.org/wiki/%E5%94%AF%E8%AE%80%E8%A8%98%E6%86%B6%E9%AB%94>`_ 可抹除可編程唯讀記憶體（Erasable Programmable Read Only Memory，EPROM）
  - 利用高電壓將資料編程寫入，但抹除時需將線路曝光於紫外線下一段時間，資料始可被清空。
  - 封裝外殼上會留一個石英玻璃所製的透明窗以便進行紫外線曝光。
  - 寫入程式後通常會用貼紙遮蓋透明窗，以防日久不慎曝光過量影響資料。

- `EEPROM:<http://zh.wikipedia.org/wiki/EEPROM>`_ 電子抹除式可複寫唯讀記憶體(Electrically-Erasable Programmable Read-Only Memory)
  - 是一種可以通過電子方式多次複寫的半導體存儲設備。相比EPROM，EEPROM不需要用紫外線照射，也不需取下，就可以用特定的電壓，來抹除晶片上的訊息，以便寫入新的資料。
  - 資料更新方式:以位元組為單位

- `Flash Memory:<http://zh.wikipedia.org/wiki/Flash_memory>`_
  - 於1984年發表，Intel之後於1988年發表第一款商業型的NOR Flash晶片
  - 以價格便宜、位元密度接手EEPROM的市場位置
  - 主要用於一般性資料儲存，以及在電腦及其他數位產品間交換傳輸資料
  - EX:記憶卡、隨身碟的儲存媒介
  - 快閃記憶體是一種特殊的、以大區塊(blocks)抹寫的EEPROM，寫入大小取決於記憶體控制器本身，介於256KB~20MB不等
  - EEPROM只允許單執行緒重寫資料，快閃記憶體支援多執行緒同時在多個地方寫資料
  - 目前主機板的BIOS幾乎都是透過Flash memory儲存

1.2 NOR/NAND介紹
------------------

- **NOR Flash** : 
  - 支援隨機存取，讀資料的方式跟RAM接近，給address，data就能讀出
  - NOR的特點是原地執行(XIP, eXecute In Place)，這樣應用程序可以直接在flash memory內運行，不必再把代碼讀到系統RAM中
  - 每次寫入/擦除都是以1 block為單位;1 block = 16~128 KBytes
  - 小容量時具有很高的成本效益，但是很低的寫入和擦除速度大大影響了它的性能
  - NOR flash佔據了容量為1～16MB閃存市場的大部分，因隨機存取快，應用在手機中
  - NOR的擦寫週期壽命是一萬~十萬次
  - 適合用於儲存不需經常更新的程式，例如BIOS或韌體

- **NAND Flash**
  - Toshiba於1989年發表
  - 適用於大容量，更低的寫入和擦除時間，高密度，高壽命(10倍左右)，低製造成本
  - I/O只允許連續讀取，所以不適合用於電腦主記憶體(不支援隨機存取)
  - 讀寫操作以1 page為單位，擦除(Erase)以1 block為單位
  - 1 block = 32 pages;每個block的單位依照廠商製造的不同有區別，介於8~32 KBytes之間
  - NAND擦除單元更小，擦除速度(4ms)比NOR的(5s)快
  - 適合於數據存儲，例如:MMC、固態硬碟(SSD)、USB 3.0隨身碟、手機、數位相機
  - 甚至手機、MP3撥放器用NAND Flash當作存放多媒體檔案的媒介，原因在於成本、空間、還有寫入資料的速度
  - NAND閃存中每個區塊的最大擦寫次數是一百萬次

- **[補充]OneNAND Flash**
  - `OneNAND <http://www.digitimes.com.tw/tw/dt/n/shwnws.asp?CnlID=10&Cat=25&Cat1=&id=181788>`_ 記憶體技術，是一種混合式記憶體


1.3 NOR/NAND比較 
------------------

+-------------+--------+--------+--------+--------+--------+----------------+
|             |讀取速度|寫入速度|擦除速度|  容量  |  成本  |  市佔率  |
+=============+========+========+========+========+========+================+
|  NOR Flash  |   快   |   慢   |   慢   |   小   |   高   |       減少       |
+-------------+--------+--------+--------+--------+--------+----------------+----------------+
|  NAND Flash |   慢   |   快   |   快   |   大   |   低   |  上升  |
+-------------+--------+--------+--------+--------+--------+----------------+

- **關於NAND Flash 與 NOR Flash的比較可參考** http://www.8051faq.com.cn/manager/download/20077633203664115781250.PDF

2.Flash 記憶體架構介紹
======================

2.1 In memory architecture
-----------------------------------------

Bus Matrix:(利用round-robin演算法來仲裁)
上方為master，右方為slave，bus matrix提供master可concurrent並有效率進行存取slave。

.. image:: /bus_matrix.png
   DM00031020-referenceManual P.62

- Internal SRAM總容量 = 192KB = 64KB CCM data RAM + SRAM 112KB + SRAM 16KB。
- SRAM 112KB: 連接至I-bus，加快程式的速度；連接至D-bus，加快存取data的速度。
- SRAM 112KB及FSMC皆同時有3條bus連接至ARM Cortex-M4，大大提高bus存取的性能。
- CCM(core coupled memory)：是給Cortex-M4專用的全速64KB RAM，他們不會經過上圖的Bus Matrix，Cortex-M4與其直接相連，mapped at address 0x1000 0000 - 0x1000FFFF and accessible only by the CPU through the D-bus。其address與一般的SRAM不連續，而且DMA和周邊也無法直接使用他們，所以一般user的程式完全無法感覺有這64KB的CCM。適用於stack, heap, global variables或做高速運算緩衝，如FOC模型解耦, 網路SSL, JPEG编碼/解碼...等。
- Flash memory: CPU是透過AHB I-Code及D-Code來存取Flash，另可透過ACCEL加速code execution。
- ACCEL : Adaptive real-time memory accelerator (ART Accelerator)，主要是實現instruction prefetch queue and branch cache的機制，來儲存branches中第一道instruction及常數、中斷及副程式的呼叫，penalty會發生在第一次pipeline相關機制事件產生時，之後若發現與之前一樣的instruction，cache就會發生作用。另外，在STM32中的Flash memory是128-bit row構成的，所以每次access可以讀取8道16-bit instrction或4道32-bit instrction，如此一來可增加程式執行的速度，cpu frequency為168MHz時，讀取flash的wait state可以設為0，徹底發揮處理器效能。

.. image:: /stm32-f4-art-accelerator-block-diagram.jpg


**(例)多重bus的pararrel處理:**

1. 壓縮的音樂資料流傳輸到16KB SRAM的buffer。
2. Cortex-M4執行MP3解碼程式。
3. Cortex-M4抓MP3的資料進行解碼。
4. 解壓後的音樂資料流傳輸至112KB SRAM。
5. 資料通過DMA傳輸到I2S輸出。


2.2 Flash interface in system architecture
---------------------------------------------

.. image:: /Flash_system_architecture.png
   DM00031020-referenceManual P.74
圖中一些縮寫的解釋如下：

- I-Code bus : Instruction bus.這條bus由Cortex-M4F連至BusMatrix，核心透過這個bus取出指令。
- D-Code bus : Data bus.這條bus由Cortex-M4F 與 64-Kbyte CCM data RAM 連至BusMatrix，核心透過這個bus讀取字母(literal)與除錯。
- S-bus：System bus. 用來存取週邊或SRAM的資料。
- AHB : Advanced High-performance Bus.
- APB : Advanced Peripheral Bus.

關於AHB與APB差異可參考 `Difference Between AHB and APB<http://www.differencebetween.net/technology/difference-between-ahb-and-apb/>`_

關於AMBA的介紹可參考 `Advanced Microcontroller Bus Architecture (AMBA)<http://en.wikipedia.org/wiki/AMBA_High-performance_Bus>`_

- DMA : Direct Memory Access. DMA提供周邊裝置與記憶體、記憶體與記憶體間高速的傳輸，而不須經由CPU的動作。
- CCM : Core Coupled Memory.給core專用的全速64KB RAM，在沒有經過BusMatrix的情況下與core直接連結。
- FLITF : Flash memory interface.
- FSMC：Flexible static memory controller
- FMC：Flexible memory controller


2.3 Flash模組的組成
-------------------------------------------------

- Main memory : 由兩個bank組成,每個bank各有4個16Kbytes Sector、1個64Kbytes Sector及7個128Kbytes Sector，一共2048Kbytes(2Mbytes).
- System memory : bootloader code 放置的地方，30Kbytes.
- OTP (One-Time Programmable) : 一次性寫入的空間，共528bytes(512+16)，如放軟體version，硬體version，key…等 for user data，可參考(http://forum.eepw.com.cn/thread/120354/1)
- Option byte : 用來設定讀寫保護、電壓level、軟硬體看門狗與Standby or Stop模式下的重置，每個bank各一個，共32(16+16)bytes.

.. image:: /flash module organization.png
   DM00031020-referenceManual P.77

STM32F407中的Flash有以下特性：

- 容量2Mbytes，雙bank架構，支援read-while-write(RWW)
- 單次讀取data為128bits
- 單次寫入可以byte, half-word, word以及double word為單位
- 抹除可以sector為單位或是bank以及mass(全部)操作




3 Flash 操作
============
**基本觀念：**

- Flash的每個cell在寫的時候只能1->0，不能從0->1；而erase後，該sector中所有的cell值皆為1。
- 當bit寫入由1寫成0時，不需要先erase；但若將0寫為1時，則需要先erase才能寫。

3.1 Read interface(讀取)
----------------------------------

- 為了要正確的從Flash中讀取data，必須在Flash access control register(FLASH_ACR)中，依據CPU clock frequency(HCLK)與device供應的電壓，來設定正確的wait states(LATENCY)值。
- 因為CPU的運行速度遠比Flash快得多，依下表來看，STM32F407的Flash最快access速度為<=30MHZ，如果CPU frequency超過此速度，那就必須增加等待時間。wait states與CPU clock freqency的關係如下表所示 :

.. image:: /embedded/number_of_wait_states.png
   DM00031020-referenceManual P.81

- 在Reset之後，CPU clock frequency為16MHz，並且FLASH_ACR中的wait states值被設為0。
- 官方文件建議若要調整wait states值(當加快/減慢CPU frequency時)，依據CPU frequency調試存取Flash所需的ws數。

**當加快CPU frequency時**

1. 在FLASH_ACR register中的LATENCY bits設定新的wait states值。

::

  000: 0ws(1 CPU cycle)
  001: 1ws(2 CPU cycle)
  010: 2ws(3 CPU cycle)
  011: 3ws(4 CPU cycle)
  100: 4ws(5 CPU cycle)
  101: 5ws(6 CPU cycle)
  110: 6ws(7 CPU cycle)
  111: 7ws(8 CPU cycle)


2. 透過讀取FLASH_ACR register，確認新的wait states值有被無設定成功。
3. 再透過寫入RCC_CFGR(Reset and Clock Control Configuration Register)中的SW(System clock switch) bits來修改 CPU clock source.

::

  sw : 
  00 : HSI (High Speed Internal)
  01 : HSE (High Speed External)
  10 : PLL (Phase Lock Loop)
  11 : not allowed

- 當離開Stop或Standby模式時，或者當HSE Failure時，將由硬體強制轉為HSI。可參考(http://blog.csdn.net/joji_h/article/details/5581340)

4. 如果需要，可透過寫入RCC_CFGR register中的HPRE(AHB Prescaler) bits來修改CPU clock prescaler以調整clock freqency.

::

  HPRE bits:
  0xxx : System clock not divided
  1000 : System clock divided by 2
  1001 : System clock divided by 4
  1010 : System clock divided by 8
  ...
  1111 : System clock divided by 512


5. 透過讀取RCC_CFGR register中的SWS(System clock switch status) bits 來確認新的SW(System clock switch) bits有無被設定成功；透過讀取RCC_CFGR register中的來確定新的HPRE(AHB Prescaler) bits有無被設定成功。

**當減慢CPU frequency時**

1. 透過寫入RCC_CFGR(Reset and Clock Control Configuration Register)中的SW(System clock switch) bits來修改 CPU clock source.
2. 如果需要，可透過寫入RCC_CFGR register中的HPRE(AHB Prescaler) bits來修改CPU clock prescaler以調整clock freqency.
3. 透過讀取讀取RCC_CFGR register中的SWS(System clock switch status) bits 來確認新的SW(System clock switch) bits有無被設定成功；透過讀取RCC_CFGR register中的來確定新的HPRE(AHB Prescaler) bits有無被設定成功。
4. 在FLASH_ACR register中的LATENCY bits設定新的wait states值。
5. 透過讀取FLASH_ACR register，確認新的wait states值有被無設定成功。

p.s. 加快cpu freqency的step 1~2等於減慢cpu freqency的step4~5；加快cpu freqency的step 3~5等於減慢cpu freqency的step1~3。

3.2 Erase and program operations
---------------------------------------
**操作前需知**

- CPU clock frequency必須至少要在1MHZ以上，Flash才能做erase及program的操作，若在操作的途中發生reset，則不保證Flash中內容正確。
- Flash在program/erase操作時，任何欲read Flash的操作會被暫停，需直到program操作完成後，read操作才會被正確的執行。這也代表當program/erase操作正在執行中，code or data fetch(即read)無法執行。

在做抹除與寫入動作之前，必須先設定Flash control register(FLASH_CR)，然而在Reset之後，FLASH_CR是不可寫入的。因此必須透過以下方法解鎖：

1. 在Flash key register(FLASH_KEYR)中寫入0x45670123。
2. 在Flash key register(FLASH_KEYR)中寫入0xCDEF89AB。

**必須連續執行1與2才會解鎖**

- 若步驟錯誤一樣會鎖住FLASH_CR，直到reset後才能用以上方式解鎖。
- 若解鎖後要再次鎖住，只要在FLASH_CR中設定LOCK bit即可。

此外，FLASH_CR在FLASH_SR的BSY值為1時是同樣不可寫入的。


3.3 Program/erase parallelism (寫入/抹除並行)
----------------------------------------------------
- Parallelism為在操作program或erase時，最大能夠寫幾bit的0。
- PSIZE是在FLASH_CR register中，此值必須在programming/erasing前正確的被寫入。對應表如下表：

.. image:: /parallelism.JPG
   DM00031020-referenceManual P.85

- 以下是各種型態單次寫入時所需的大小
- **Byte : x8**
- **Half-word : x16**
- **Word : x32**
- **Double-word : x64**

3.4 Erase (抹除)
-----------------

Flash memory erase的操作可以以sector為單位，或是整個Flash memory全部erase，也就是Mass Erase。而Mass Erase並不會影響OTP sector或是設定區的sector。

- **區塊抹除(Sector Erase)**:

1. 檢查Flash status register(FLASH_SR)中BSY(Busy) bit是否為0。(0代表目前沒有其他的Flash操作，1代表有其他Flash操作正在進行中)
2. 設定FLASH_CR register中SER(Sector Erase) bit告知啟用區塊抹除，並設定SNB(Sector number) bit告知欲抹除的區塊。

::

  0000 sector 0
  0001 sector 1
  ...
  1011 sector 11
  不得超過此範圍。

3. 設定FLASH_CR register中的STRT(Start) bit。
4. 等待FLASH_SR register中的BSY bit清空。

- **大量抹除(Mass Erase)**:

1. 檢查FLASH_SR register中BSY bit是否為0。
2. 設定FLASH_CR register中的MER(Mass Erase) bit。
3. 設定FLASH_CR register中的STRT bit。
4. 等待FLASH_SR register中的BSY bit清空。

3.5 Program (寫入)
-----------------------------------

1. 檢查FLASH_SR register中BSY bit是否為0。
2. 設定FLASH_CR中的PG(Programming) bit。
3. 在指定的位置(main memory block或OTP area)執行資料寫入的動作。

- Byte access in case of x8 parallelism
- Half-word access in case of x16 parallelism
- Word access in case of x32 parallelism
- Double word access in case of x64 parallelism

4. 等待FLASH_SR中的BSY bit清空。

3.6 Interrupt
----------------------------------------------------------------
- **結束時**

若要在erase或program結束時發出中斷，可以設定FLASH_CR register中的end of operation interrupt enable(EOPIE) bit，當然，FLASH_SR register中的BSY bit這時應是要0，而end of operation(EOP) bit此時為1。

- **錯誤時**

如果在program或erase操作過程中有錯誤發生，FLASH_SR register中的某一flag會被設1： 

- PGAERR, PGPERR, PGSERR (Program error flags)
- WRPERR (Protection error flag)

此時，若FLASH_CR register中的error interrupt enable bit(ERRIE)被打開(設為1)，則FLASH_SR register中的operation error bit(OPERR)會被設為1。

3.7 Option bytes
----------------------------------
**關於讀取保護(Read Protections)**

有三種Read Protections levels:

- Level 0: 將 0xAA 寫入FLASH_OPTCR中的RDP(Read Protection) bit

  1. 表示Read protection not active。

- Level 1: 將除了 0xAA 以及 0xCC 以外的值寫入FLASH_OPTCR中的RDP bit

  1. 表示由system memory和SRAM啟動且執行的processes無法對Flash memory做存取。

  2. Debug功能可以使用。

- Level 2: 將 0xCC 寫入FLASH_OPTCR中的RDP bit

  1. 表示由system memory和SRAM啟動且執行的processes無法對Flash memory做存取。

  2. Debug功能不可以使用。

  3. 一旦設定成level 2以後就無法再更改。

**關於寫入保護(Write Protections)**

- 在12個User Sector中(請見5.Flash記憶體架構介紹)，Flash memory可以設為保護狀態來避免非預期的寫入操作造成的數據遺失問題。

- 當FLASH_OPTCR中的nWRPi(non-write protection) bit (0 <= i <= 11)為0時，i所對應的sector就不能夠被寫入或抹除。同樣地，在大量抹除中，只要在抹除範圍內有任何一個Sector是寫入保護的狀態，就不能夠進行抹除。

- 若嘗試在寫入保護的區域中進行寫入/抹除的行為，將會在FLASH_SR中設置WRPERR(Write protection error flag)。

**關於Brown Out Reset Level(BOR_LEV)**
 - 當工作電壓低於或高於指定的電壓範圍時，該元件會自動進入reset狀態直到電壓回復到範圍內。目的為防止一些不穩定或不可預期的電壓變化。(請看暫存器介紹)

3.8 One-time programmable (OTP)
-------------------------------------------------------------
- 一次性可編程唯讀記憶體（One Time Programmable Read Only Memory，OTPROM）之寫入原理同EPROM，但是為了節省成本，編程寫入之後就不再抹除，因此不設置透明窗(不能被抹除)。
- 總共528 bytes
  - OTP bytes(512 bytes)
  - OTP lock bytes(16 bytes)

- OTP bytes:16個block，每個block有32bytes(總共512 bytes)--for user data
- OTP lock bytes:有16 bytes LOCKBi (0 ≤ i ≤ 15)分別控制相對應的16個block--for locking the correspaonding OTP
- 在OTP lock byte 為 0x00 的時候，OTP 才可以被寫入資料(原本為0xFF)；而OTP block byte只能為0x00或是0xFF，否則OTP可能會讀不到正確的值
 
.. image:: http://3.bp.blogspot.com/-F9ULpiVgyY8/Uqkt_At7hMI/AAAAAAAAAD0/0px2QSGozeI/s1600/OTP.png
   DM00031020-referenceManual P.97

4.Flash interface registers
===========================
- read/write (rw) :Software can read and write to these bits.
- read-only (r) :Software can only read these bits.
- write-only (w) :Software can only write to this bit. Reading the bit returns the reset value.
- read/clear (rc_w1) :Software can read as well as clear this bit by writing 1. Writing ‘0’ has no effect on the bit value.
- read/clear (rc_w0) :Software can read as well as clear this bit by writing 0. Writing ‘1’ has no effect on the bit value.
- read/set (rs) :Software can read as well as set this bit. Writing ‘0’ has no effect on the bit value.

4.1 Flash access control register (FLASH_ACR)
-----------------------------------------------

Address offset : 0x00, Reset value: 0x0000 0000.

.. image:: /Flash_acr.JPG
   DM00031020-referenceManual P.97

::

  Bits 31:13 保留位置，必須保持淨空。
  Bit 12 DCRST : Data cache reset. 0: not reset; 1: reset. (當D cache未啟用時才可寫入)
  Bit 11 ICRST : Instruction cache reset. 0: not reset ; 1: reset. (當I cache未啟用時才可寫入)
  Bit 10 DCEN : Data cache enable. 0: disabled; 1: enabled.
  Bit 9 ICEN : Instruction cache enable. 0: disabled; 1: enabled.
  Bit 8 PRFTEN : Prefetch enable. 0: disabled; 1: enabled;
  Bits 7:3 保留位置，必須保持淨空。
  Bits 2:0 LATENCY : Latency.

4.2 Flash key register (FLASH_KEYR)
-------------------------------------

Address offset : 0x04, Reset value: 0x0000 0000.

.. image:: /flash_keyr.JPG
   DM00031020-referenceManual P.99

::

  Bits 31:0 FKEYR : FPEC key. 解鎖用，前方已經描述過如何解鎖FLASH_CR，在此不贅述。

4.3 Flash status register (FLASH_SR)
-------------------------------------

Address offset : 0x0C, Reset value: 0x0000 0000.

.. image:: /flash_sr.JPG
   DM00031020-referenceManual P.101

::

  Bits 31:17 保留位置，必須保持淨空。
  Bit 16 BSY : Busy. 0: 無其他記憶體操作; 1: 其他記憶體操作進行中。(若無任何操作時會自動清除)
  Bits 15:8 保留位置，必須保持淨空。
  Bit 7 PGSERR : Programming sequence error. 當程式出現錯誤時會設值。若寫入1則清空。
  Bit 6 PGPERR : Programming parallelism error. 當程式寫入大小與型態不符(對照PSIZE)時會設值。若寫入1則清空。
  Bit 5 PGAERR : Programming alignment error. 當資料寫入時無法塞入128-bit的Flash memory row會設值。若寫入1則清空。
  Bit 4 WRPERR : Write protection error. 當嘗試寫入/抹除一個寫入保護的Flash memory區域時會設值。若寫入1則清空。
  Bit 3:2 保留位置，必須保持淨空。
  Bit 1 OPERR : Operation error. 當任何的Flash操作失效時設值，但這個bit只會在ERRIE(Error Interrupts)啟用時生效。
  Bit 0 EOP : End of Operation. 當一或多個Flash操作成功完成時設值，這個bit只會在EOPIE(End of Operation Interrupts)啟用時生效。若寫入1則清空。

4.4 Flash control register (FLASH_CR)
-------------------------------------

Address offset : 0x10, Reset value: **0x8000** 0000.

.. image:: /flash_cr.JPG
   DM00031020-referenceManual P.105

::

  Bit 31 LOCK : Lock. 只能寫為1，當值為1時，FLASH_CR將鎖住不可更改，唯有偵測到解鎖序列才會清除。
  Bits 30:26 保留位置，必須保持淨空。
  Bit 25 ERRIE: Error interrupt enable. 0: Disabled; 1: Enabled.
  Bit 24 EOPIE: End of operation interrupt enable. 0: Disabled; 1: Enabled.
  Bits 23:17 保留位置，必須保持淨空。
  Bit 16 STRT: Start. 只能由軟體設置，且在BSY bit清空時會一併清空。
  Bits 15:10 保留位置，必須保持淨空。
  Bits 9:8 PSIZE: Program size. 前方有提過PSIZE的設置，在此不贅述。
  Bits 6:3 SNB: Sector number. 前方有提過SNB的設置，在此不贅述。
  Bit 2 MER: Mass Erase.
  Bit 1 SER: Sector Erase.
  Bit 0 PG: Programming.

4.5 Flash option control register (FLASH_OPTCR)
-----------------------------------------------

Address offset : 0x14, Reset value: **0x0FFF AAED**.

.. image:: /flash_optcr.JPG
   DM00031020-referenceManual P.106

::

  Bits 31:28 保留位置，必須保持淨空。
  Bits 27:16 nWRP: Not write protect. 0: write protection active; 1: write protection not active.
  Bits 15:8 RDP: Read protect. 0xAA : Level 0, read protection not active; 0xCC : Level 2, chip read protection active; Others : Level 1, read protection of memories active.
  Bits 7:5 USER: User option bytes
  Bit 4 保留位置，必須保持淨空。
  Bits 3:2 BOR_Level: BOR reset level.
    00 : BOR level 3, 電壓 2.70~3.60V
    01 : BOR level 2, 電壓 2.40~2.70V
    10 : BOR level 1, 電壓 2.10~2.40V
    11 : BOR off, 電壓 1.80~2.10V
  Bit 1 OPTSTRT: Option start.
  Bit 0 OPTLOCK: Option lock.


5.Example
=================

5.1 LED LEGEND
--------------

- GREEN : FLASH is unlocked.
- BLUE  : FLASH is writing.
- RED   : FLASH is erasing.
- YELLOW: FLASH is reading.

5.2 git repository
------------------
 
- git repo: https://github.com/choupc/stm32_flash_demo


5.3 operation flow
------------------

- 1.Flash unlock
- GREEN LED ON

::

  FLASH_Unlock();
  STM_EVAL_LEDOn(LED4);
  printf("\r\n FLASH Unlock \r\n");
  FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | 
                  FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR|FLASH_FLAG_PGSERR); 


- 2.Erase from sector2 to sector 11 
- RED LED ON
- 3.Erase complete 
- RED LED OFF

::

 for (i = StartSector; i <= EndSector; i += 8)
     STM_EVAL_LEDOn(LED5);
     printf("\r\n Erase sector:%d \r\n",a);
     if (FLASH_EraseSector(i, VoltageRange_3) != FLASH_COMPLETE)


- 4.Write from sector2 to sector 11 as "0x12345678"
- BLUE LED ON
- 5.Finished write process
- BLUE LED OFF


::

  printf("\r\n FLASH is writing... \r\n"); 
  while (Address < FLASH_USER_END_ADDR){
    STM_EVAL_LEDOn(LED6);
    if (FLASH_ProgramWord(Address, DATA_32) == FLASH_COMPLETE) {


- 6.Flash lock
- GREEN LED OFF

::

  FLASH_Lock(); 
  STM_EVAL_LEDOff(LED4);
  printf("\r\n FLASH lock \r\n");

- 7.Verification (Reading...)
- YELLOW LED ON
- 8.Read complete
- YELLOW LED OFF

::

  printf("\r\n FLASH is reading... \r\n");
    while (Address < FLASH_USER_END_ADDR){
    STM_EVAL_LEDOn(LED3);
    data32 = *(__IO uint32_t*)Address;
    
    if (data32 != DATA_32){
     
    printf("\r\n Read error \r\n");

    }
    Address = FLASH_USER_END_ADDR;
    STM_EVAL_LEDOff(LED3);
  } printf("\r\n Read complete \r\n");

- 9.進入等待狀態


5.4 DEMO
------------------
 

- Flash memory sector2 的內容:

.. image:: /1492801_611112942271128_116086978_n.jpg


- Demo video

- http://www.youtube.com/watch?v=yW_IF_wHWBc&feature=youtu.be


6.STM32F407VG 硬體介紹
=====================

.. image:: /block_diag_1.JPG

.. image:: /block_diag_2.JPG
   DM00037051-datasheet P.18


7.reference
===========

- https://gitcafe.com/xturtle/NCKU-Embedded-2012-Flash-Demo
- http://wiki.csie.ncku.edu.tw/embedded/learn-stm32-part-1.pdf
- http://wiki.csie.ncku.edu.tw/embedded/learn-stm32-part-6.pdf
- http://www.triplespark.net/elec/pdev/arm/stm32.html
- http://www.codeproject.com/Articles/14983/Remote-Debugging-using-GDB
- http://cms.mcuapps.com/products/stm32f4-discovery/README.html
- http://cms.mcuapps.com/techinfo/toolchains/openocd/
- http://www.st.com/internet/mcu/product/252140.jsp
- http://zh.wikipedia.org/wiki/%E9%97%AA%E5%AD%98
- `快閃記憶體(wiki)<http://zh.wikipedia.org/wiki/%E5%BF%AB%E9%96%83%E8%A8%98%E6%86%B6%E9%AB%94>`_
- http://www.eetasia.com/ART_8800627935_480200_NT_1866240e.HTM
- http://www.xuan.idv.tw/wordpress/?p=821
- `Nand Flash 基本介紹 <http://cmchao.logdown.com/posts/60216>`_
- `Nand Flash BBT Support in Linux  <http://cmchao.logdown.com/posts/61616-nand-flash-support-in-linux>`_
- http://www.ptt.cc/bbs/NTU-EM93/M.1253794167.A.8F8.html
- `[轉載]Nand flash結構以及讀寫經典分析<http://blog.xuite.net/ffc99a3b/ooxx/35948314-%5B%E8%BD%89%E8%BC%89%5DNand+flash%E7%B5%90%E6%A7%8B%E4%BB%A5%E5%8F%8A%E8%AE%80%E5%AF%AB%E7%B6%93%E5%85%B8%E5%88%86%E6%9E%90>`_