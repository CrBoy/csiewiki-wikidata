---
title: Flash
categories: STM32F4
...

1.Flash 簡介
============

1.1 簡介
-------------

- 快閃記憶體(Flash Memory、閃存)，主要用於一般性資料儲存，以及在電腦及其他數位產品間交換傳輸資料。如記憶卡、隨身碟等。快閃記憶體是一種特殊的、以大區塊抹寫的EEPROM(電子抹除式可複寫唯讀記憶體)。

- 快閃記憶體晶片的低階介面通常與透過支援外界的定址匯流排行隨機存取的DRAM、ROM、EEPROM等記憶體不同。 NOR Flash本身為讀取操作(支援隨機存取)提供外部定址匯流排；至於解鎖、抹除與寫入則須以區塊-區塊(Block-by-block)的方式進行，典型的區塊大小為64、128或256位元組。NAND Flash所有的動作都必須以區塊性基礎(Block-wise fashion)執行，包含讀、寫、解鎖與抹除。

- `EEPROM(wiki):<http://zh.wikipedia.org/wiki/EEPROM>`_ 全稱電子抹除式可複寫唯讀記憶體(英語:Electrically-Erasable Programmable Read-Only Memory)，是一種可以通過電子方式多次複寫的半導體存儲設備。相比EPROM，EEPROM不需要用紫外線照射，也不需取下，就可以用特定的電壓，來抹除晶片上的訊息，以便寫入新的資料。

- `EPROM(wiki):<http://zh.wikipedia.org/wiki/%E5%94%AF%E8%AE%80%E8%A8%98%E6%86%B6%E9%AB%94>`_ 可抹除可編程唯讀記憶體（Erasable Programmable Read Only Memory，EPROM）可利用高電壓將資料編程寫入，但抹除時需將線路曝光於紫外線下一段時間，資料始可被清空，再供重複使用。因此，在封裝外殼上會預留一個石英玻璃所製的透明窗以便進行紫外線曝光。寫入程式後通常會用貼紙遮蓋透明窗，以防日久不慎曝光過量影響資料。


1.2 NOR/NAND介紹
------------------

- NOR Flash : 
  - NOR的特點是芯片內執行(XIP, eXecute In Place)，這樣應用程序可以直接在flash閃存內運行，不必再把代碼讀到系統RAM中
  - 小容量時具有很高的成本效益，但是很低的寫入和擦除速度大大影響了它的性能
  - NOR flash佔據了容量為1～16MB閃存市場的大部分，主要應用在手機中(16MB、32MB)
  - NOR的擦寫次數是十萬次

- NAND Flash
  - 適用於大容量
  - NAND flash只是用在8～128MB的產品當中，適合於數據存儲，例如:eMMC、固態硬碟(SSD)USB 3.0隨身碟
  - NAND閃存中每個塊的最大擦寫次數是一百萬次


1.3 NOR/NAND比較 
------------------

+-------------+--------+--------+--------+--------+--------+----------------+----------------+
|             |讀取速度|寫入速度|擦除速度|  容量  |  成本  |每次操作區塊(KB)|  每次操作時間  |
+=============+========+========+========+========+========+================+================+
|  NOR Flash  |   快   |   慢   |   慢   |   小   |   高   |     64~128     |       5s       |
+-------------+--------+--------+--------+--------+--------+----------------+----------------+
|  NAND Flash |   慢   |   快   |   快   |   大   |   低   |      8~32      |  4ms(快125倍)  |
+-------------+--------+--------+--------+--------+--------+----------------+----------------+

- **關於NAND Flash 與 NOR Flash的比較可參考** http://www.8051faq.com.cn/manager/download/20077633203664115781250.PDF
- 一個典型的NAND大約比NOR小八倍

2.Flash 記憶體架構介紹
======================

2.1 In memory architecture
-----------------------------------------

Bus Matrix:(利用round-robin演算法來仲裁)

.. image:: /bus_matrix.JPG
   DM00031020-referenceManual P.60


- CCM(core coupled memory)：屬於Embedded SRAM中一部份，mapped at address 0x1000 0000 and accessible only by the CPU through the D-bus.
- Flash memory: CPU是透過AHB I-Code及D-Code來存取Flash，另可逶過ACCEL加速code execution。

2.2 Flash interface in system architecture
---------------------------------------------

.. image:: /Flash_system_architecture.JPG
   DM00031020-referenceManual P.73
圖中一些縮寫的解釋如下：

- I-Code bus : Instruction bus.這條bus由Cortex-M4F連至BusMatrix，核心透過這個bus取出指令。
- D-Code bus : Data bus.這條bus由Cortex-M4F 與 64-Kbyte CCM data RAM 連至BusMatrix，核心透過這個bus讀取字母(literal)與除錯。
- S-bus：System bus. 用來存取週邊或SRAM的資料。
- AHB : Advanced High-performance Bus.
- APB : Advanced Peripheral Bus.
- ACCEL : Adaptive real-time memory accelerator (ART Accelerator)，主要是實現instruction prefetch queue and branch cache的機制，來儲存branches中第一道instruction及常數、中斷及副程式的呼叫，penalty會發生在第一次pipeline相關機制事件產生時，之後若發現與之前一樣的instruction，cache就會發生作用。另外，在STM32中的Flash memory是128-bit row構成的，所以每次access可以讀取8道16-bit instrction或4道32-bit instrction，如此一來可增加程式執行的速度，cpu frequency為168MHz時，讀取flash的wait state可以設為0，徹底發揮處理器效能。

.. image:: /ST_ARTAccelerator_big.jpg

關於AHB與APB差異可參考 `Difference Between AHB and APB<http://www.differencebetween.net/technology/difference-between-ahb-and-apb/>`_

關於AMBA的介紹可參考 `Advanced Microcontroller Bus Architecture (AMBA)<http://en.wikipedia.org/wiki/AMBA_High-performance_Bus>`_

- DMA : Direct Memory Access. DMA提供周邊裝置與記憶體、記憶體與記憶體間高速的傳輸，而不須經由CPU的動作。
- CCM : Core Coupled Memory.給core專用的全速64KB RAM，在沒有經過BusMatrix的情況下與core直接連結。
- FLITF : Flash memory interface.
- FSMC：Flexible static memory controller
- FMC：Flexible memory controller


2.3 Flash模組的組成
-------------------------------------------------

- A main memory block divided into sectors.
- Main memory : 4個16Kbytes Sector、1個64Kbytes Sector及7個128Kbytes Sector，一共1024Kbytes(1Mbytes).
- System memory : bootloader code 放置的地方，30Kbytes.
- OTP (One-Time Programmable) : 一次性寫入的空間，共528Kbytes(512+16)，如放軟體version，硬體version，key…等 for user data，可參考(http://forum.eepw.com.cn/thread/120354/1)
- Option byte : 用來設定讀寫保護、電壓level、軟硬體看門狗與Standby or Stop模式下的重置，共16Kbytes.

.. image:: /flash module organization.JPG
   DM00031020-referenceManual P.75

STM32F407中的Flash有以下特性：

- 容量為1Mbyte
- 單次讀取data為128bits
- 單次寫入可以byte, half-word, word以及double word為單位
- 抹除可以sector為單位或是mass(全部)操作




3 Flash 操作
============
**基本觀念：**

- Flash的每個cell在寫的時候只能1->0，不能從0->1；而erase後，該sector中所有的cell值皆為1。
- 當bit寫入由1寫成0時，不需要先erase；但若將0寫為1時，則需要先erase才能寫。

3.1 Read interface(讀取)
----------------------------------

- 為了要正確的從Flash中讀取data，必須在Flash access control register(FLASH_ACR)中，依據CPU clock frequency(HCLK)與device供應的電壓，來設定正確的wait states(LATENCY)值。
- 因為CPU的運行速度遠比Flash快得多，依下表來看，STM32F407的Flash最快access速度為<=30MHZ，如果CPU frequency超過此速度，那就必須增加等待時間。wait states與CPU clock freqency的關係如下表所示 :

.. image:: /ws_hclk.JPG
   DM00031020-referenceManual P.80

- 在Reset之後，CPU clock frequency為16MHz，並且FLASH_ACR中的wait states值被設為0。
- 官方文件建議若要調整wait states值(當加快/減慢CPU frequency時)，依據CPU frequency調試存取Flash所需的ws數。

**當加快CPU frequency時**

1. 在FLASH_ACR register中的LATENCY bits設定新的wait states值。

::

  000: 0ws(1 CPU cycle)
  001: 1ws(2 CPU cycle)
  010: 2ws(3 CPU cycle)
  011: 3ws(4 CPU cycle)
  100: 4ws(5 CPU cycle)
  101: 5ws(6 CPU cycle)
  110: 6ws(7 CPU cycle)
  111: 7ws(8 CPU cycle)


2. 透過讀取FLASH_ACR register，確認新的wait states值有被無設定成功。
3. 再透過寫入RCC_CFGR(Reset and Clock Control Configuration Register)中的SW(System clock switch) bits來修改 CPU clock source.

::

  sw : 
  00 : HSI (High Speed Internal)
  01 : HSE (High Speed External)
  10 : PLL (Phase Lock Loop)
  11 : not allowed

- 當離開Stop或Standby模式時，或者當HSE Failure時，將由硬體強制轉為HSI。可參考(http://blog.csdn.net/joji_h/article/details/5581340)

4. 如果需要，可透過寫入RCC_CFGR register中的HPRE(AHB Prescaler) bits來修改CPU clock prescaler以調整clock freqency.

::

  HPRE bits:
  0xxx : System clock not divided
  1000 : System clock divided by 2
  1001 : System clock divided by 4
  1010 : System clock divided by 8
  ...
  1111 : System clock divided by 512


5. 透過讀取讀取RCC_CFGR register中的SWS(System clock switch status) bits 來確認新的SW(System clock switch) bits有無被設定成功；透過讀取RCC_CFGR register中的來確定新的HPRE(AHB Prescaler) bits有無被設定成功。

**當減慢CPU frequency時**

1. 透過寫入RCC_CFGR(Reset and Clock Control Configuration Register)中的SW(System clock switch) bits來修改 CPU clock source.
2. 如果需要，可透過寫入RCC_CFGR register中的HPRE(AHB Prescaler) bits來修改CPU clock prescaler以調整clock freqency.
3. 透過讀取讀取RCC_CFGR register中的SWS(System clock switch status) bits 來確認新的SW(System clock switch) bits有無被設定成功；透過讀取RCC_CFGR register中的來確定新的HPRE(AHB Prescaler) bits有無被設定成功。
4. 在FLASH_ACR register中的LATENCY bits設定新的wait states值。
5. 透過讀取FLASH_ACR register，確認新的wait states值有被無設定成功。

p.s. 加快cpu freqency的step 1~2等於減慢cpu freqency的step4~5；加快cpu freqency的step 3~5等於減慢cpu freqency的step1~3。

3.2 Erase and program operations
---------------------------------------
**操作前需知**

- CPU clock frequency必須至少要在1MHZ以上，Flash才能做erase及program的操作，若在操作的途中發生reset，則不保證Flash中內容正確。
- Flash在program/erase操作時，任何欲read Flash的操作會被暫停，需直到program操作完成後，read操作才會被正確的執行。這也代表當program/erase操作正在執行中，code or data fetch(即read)無法執行。

在做抹除與寫入動作之前，必須先設定Flash control register(FLASH_CR)，然而在Reset之後，FLASH_CR是不可寫入的。因此必須透過以下方法解鎖：

1. 在Flash key register(FLASH_KEYR)中寫入0x45670123。
2. 在Flash key register(FLASH_KEYR)中寫入0xCDEF89AB。

**必須連續執行1與2才會解鎖**

- 若步驟錯誤一樣會鎖住FLASH_CR，直到reset後才能用以上方式解鎖。
- 若解鎖後要再次鎖住，只要在FLASH_CR中設定LOCK bit即可。

此外，FLASH_CR在FLASH_SR的BSY值為1時是同樣不可寫入的。


3.3 Program/erase parallelism (寫入/抹除並行)
----------------------------------------------------
- Parallelism為在操作program或erase時，最大能夠寫幾bit的0。
- PSIZE是在FLASH_CR register中，此值必須在programming/erasing前正確的被寫入。對應表如下表：

.. image:: /parallelism.JPG
   DM00031020-referenceManual P.85

- 以下是各種型態單次寫入時所需的大小
- **Byte : x8**
- **Half-word : x16**
- **Word : x32**
- **Double-word : x64**

3.4 Erase (抹除)
-----------------

Flash memory erase的操作可以以sector為單位，或是整個Flash memory全部erase，也就是Mass Erase。而Mass Erase並不會影響OTP sector或是設定區的sector。

- **區塊抹除(Sector Erase)**:

1. 檢查Flash status register(FLASH_SR)中BSY(Busy) bit是否為0。(0代表目前沒有其他的Flash操作，1代表有其他Flash操作正在進行中)
2. 設定FLASH_CR register中SER(Sector Erase) bit告知啟用區塊抹除，並設定SNB(Sector number) bit告知欲抹除的區塊。

::

  0000 sector 0
  0001 sector 1
  ...
  1011 sector 11
  不得超過此範圍。

3. 設定FLASH_CR register中的STRT(Start) bit。
4. 等待FLASH_SR register中的BSY bit清空。

- **大量抹除(Mass Erase)**:

1. 檢查FLASH_SR register中BSY bit是否為0。
2. 設定FLASH_CR register中的MER(Mass Erase) bit。
3. 設定FLASH_CR register中的STRT bit。
4. 等待FLASH_SR register中的BSY bit清空。

3.5 Program (寫入)
-----------------------------------

1. 檢查FLASH_SR register中BSY bit是否為0。
2. 設定FLASH_CR中的PG(Programming) bit。
3. 在指定的位置(main memory block或OTP area)執行資料寫入的動作。

- Byte access in case of x8 parallelism
- Half-word access in case of x16 parallelism
- Word access in case of x32 parallelism
- Double word access in case of x64 parallelism

4. 等待FLASH_SR中的BSY bit清空。

3.6 Interrupt
----------------------------------------------------------------
- **結束時**

若要在erase或program結束時發出中斷，可以設定FLASH_CR register中的end of operation interrupt enable(EOPIE) bit，當然，FLASH_SR register中的BSY bit這時應是要0，而end of operation(EOP) bit此時為1。

- **錯誤時**

如果在program或erase操作過程中有錯誤發生，FLASH_SR register中的某一flag會被設1： 

- PGAERR, PGPERR, PGSERR (Program error flags)
- WRPERR (Protection error flag)

此時，若FLASH_CR register中的error interrupt enable bit(ERRIE)被打開(設為1)，則FLASH_SR register中的operation error bit(OPERR)會被設為1。

3.7 Option bytes
----------------------------------
**關於讀取保護(Read Protections)**

有三種Read Protections levels:

- Level 0:將0xAA寫入FLASH_OPTCR中的RDP(Read Protection) bit，表示Read protection not active。

- Level 1:將除了0xAA以及0xCC以外的值寫入FLASH_OPTCR中的RDP bit，表示Memory read protection active。

- Level 2:將0xCC寫入FLASH_OPTCR中的RDP bit，表示Disable debug/chip read protection。

Memory read protection:通過debug調整修改後的processes以及由RAM啟動且執行的processes無法對Flash memory做存取。

Disable debug/chip read protection:所有debug的功能被關閉，且由system memory和SRAM啟動且執行的processes無法對Flash memory做存取。

Level 2包含了Level 1的特性，一旦設定成Level 2以後就不能再設定回Level 0 或Level 1。

**關於寫入保護(Write Protections)**

在12個User Sector中(請見5.Flash記憶體架構介紹)，Flash memory可以設為保護狀態來避免非預期的寫入操作造成的數據遺失問題。當FLASH_OPTCR中的nWRPi(non-write protection) bit (0 <= i <= 11)為0時，i所對應的sector就不能夠被寫入或抹除。同樣地，在大量抹除中，只要在抹除範圍內有任何一個Sector是寫入保護的狀態，就不能夠進行抹除。

若嘗試在寫入保護的區域中進行寫入/抹除的行為，將會在FLASH_SR中設置WRPERR(Write protection error flag)。

**關於Brown Out Reset Level(BOR_LEV)**
 - 當工作電壓降低到指定的電壓門檻時，該元件會自動進入reset狀態直到電壓高於電壓門檻。目的為防止一些不穩定或不可預期的電壓變化。(請看暫存器介紹)

3.8 One-time programmable (OTP)
-------------------------------------------------------------
- 一次性可編程唯讀記憶體（One Time Programmable Read Only Memory，OTPROM）之寫入原理同EPROM，但是為了節省成本，編程寫入之後就不再抹除，因此不設置透明窗(不能被抹除)。
- 總共528 bytes
  - OTP bytes(512 bytes)
  - OTP lock bytes(16 bytes)
- OTP bytes:16個block，每個block有32bytes(總共512 bytes)--for user data
- OTP lock bytes:有16 bytes LOCKBi (0 ≤ i ≤ 15)分別控制相對應的16個block--for locking the correspaonding OTP
- 在OTP lock byte 不為 0x00 的時候，OTP 可以被寫入資料；而OTP block byte只能為0x00或是0xFF，否則OTP可能會讀不到正確的值
 
.. image:: http://3.bp.blogspot.com/-F9ULpiVgyY8/Uqkt_At7hMI/AAAAAAAAAD0/0px2QSGozeI/s1600/OTP.png
   DM00031020-referenceManual P.97

4.Flash interface registers
===========================

4.1 Flash access control register (FLASH_ACR)
-----------------------------------------------

Address offset : 0x00, Reset value: 0x0000 0000.

.. image:: /Flash_acr.JPG
   DM00031020-referenceManual P.97

::

  Bits 31:11 保留位置，必須保持淨空。
  Bit 12 DCRST : Data cache reset. 0: not reset; 1: reset. (當D cache未啟用時才可寫入)
  Bit 11 ICRST : Instruction cache reset. 0: not reset ; 1: reset. (當I cache未啟用時才可寫入)
  Bit 10 DCEN : Data cache enable. 0: disabled; 1: enabled.
  Bit 9 ICEN : Instruction cache enable. 0: disabled; 1: enabled.
  Bit 8 PRFTEN : Prefetch enable. 0: disabled; 1: enabled;
  Bits 7:3 保留位置，必須保持淨空。
  Bits 2:0 LATENCY : Latency.

4.2 Flash key register (FLASH_KEYR)
-------------------------------------

Address offset : 0x04, Reset value: 0x0000 0000.

.. image:: /flash_keyr.JPG
   DM00031020-referenceManual P.99

::

  Bits 31:0 FKEYR : FPEC key. 解鎖用，前方已經描述過如何解鎖FLASH_CR，在此不贅述。

4.3 Flash status register (FLASH_SR)
-------------------------------------

Address offset : 0x0C, Reset value: 0x0000 0000.

.. image:: /flash_sr.JPG
   DM00031020-referenceManual P.101

::

  Bits 31:17 保留位置，必須保持淨空。
  Bit 16 BSY : Busy. 0: 無其他記憶體操作; 1: 其他記憶體操作進行中。
  Bits 15:8 保留位置，必須保持淨空。
  Bit 7 PGSERR : Programming sequence error. 當程式出現錯誤時會設值。若寫入1則清空。
  Bit 6 PGPERR : Programming parallelism error. 當程式寫入大小與型態不符(對照PSIZE)時會設值。若寫入1則清空。
  Bit 5 PGAERR : Programming alignment error. 當資料寫入時無法塞入128-bit的Flash memory row會設值。若寫入1則清空。
  Bit 4 WRPERR : Write protection error. 當嘗試寫入/抹除一個寫入保護的Flash memory區域時會設值。若寫入1則清空。
  Bit 3:2 保留位置，必須保持淨空。
  Bit 1 OPERR : Operation error. 當任何的Flash操作失效時設值，但這個bit只會在ERRIE(Error Interrupts)啟用時生效。
  Bit 0 EOP : End of Operation. 當一或多個Flash操作成功完成時設值，這個bit只會在EOPIE(End of Operation Interrupts)啟用時生效。若寫入1則清空。

4.4 Flash control register (FLASH_CR)
-------------------------------------

Address offset : 0x10, Reset value: **0x8000** 0000.

.. image:: /flash_cr.JPG
   DM00031020-referenceManual P.105

::

  Bit 31 LOCK : Lock. 只能寫為1，當值為1時，FLASH_CR將鎖住不可更改，唯有偵測到解鎖序列才會清除。
  Bits 30:26 保留位置，必須保持淨空。
  Bit 25 ERRIE: Error interrupt enable. 0: Disabled; 1: Enabled.
  Bit 24 EOPIE: End of operation interrupt enable. 0: Disabled; 1: Enabled.
  Bits 23:17 保留位置，必須保持淨空。
  Bit 16 STRT: Start. 只能由軟體設置，且在BSY bit清空時會一併清空。
  Bits 15:10 保留位置，必須保持淨空。
  Bits 9:8 PSIZE: Program size. 前方有提過PSIZE的設置，在此不贅述。
  Bits 6:3 SNB: Sector number. 前方有提過SNB的設置，在此不贅述。
  Bit 2 MER: Mass Erase.
  Bit 1 SER: Sector Erase.
  Bit 0 PG: Programming.

4.5 Flash option control register (FLASH_OPTCR)
-----------------------------------------------

Address offset : 0x14, Reset value: **0x0FFF AAED**.

.. image:: /flash_optcr.JPG
   DM00031020-referenceManual P.106

::

  Bits 31:28 保留位置，必須保持淨空。
  Bits 27:16 nWRP: Not write protect. 0: write protection active; 1: write protection not active.
  Bits 15:8 RDP: Read protect. 0xAA : Level 0, read protection not active; 0xCC : Level 2, chip read protection active; Others : Level 1, read protection of memories active.
  Bits 7:5 USER: User option bytes
  Bit 4 保留位置，必須保持淨空。
  Bits 3:2 BOR_Level: BOR reset level.
    00 : BOR level 3, 電壓 2.70~3.60V
    01 : BOR level 2, 電壓 2.40~2.70V
    10 : BOR level 1, 電壓 2.10~2.40V
    11 : BOR off, 電壓 1.80~2.10V
  Bit 1 OPTSTRT: Option start.
  Bit 0 OPTLOCK: Option lock.


5.Example
=================

5.1 LED LEGEND
--------------

- GREEN : FLASH is unlocked.
- BLUE  : FLASH is writing.
- RED   : FLASH is erasing.
- YELLOW: FLASH is reading.

5.2 git repository
------------------
 
- git repo: https://github.com/choupc/stm32_flash_demo

(參考：https://gitcafe.com/xturtle/NCKU-Embedded-2012-Flash-Demo)

5.3 operation flow
------------------

- 1 FLASH_UNLOCK
- 2 GREEN LED ON

::

  FLASH_Unlock();
  STM_EVAL_LEDOn(LED4);
  printf("\r\n FLASH Unlock \r\n");
  FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | 
                  FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR|FLASH_FLAG_PGSERR); 

- 3 WRITE FROM SECTOR 2 TO SECTOR 11 AS "0x12345678"
- 4 BLUE LED ON
- 5 FINISHED WRITE PROCESS
- 6 BLUE LED OFF


::

  printf("\r\n FLASH is writing... \r\n"); 
  while (Address < FLASH_USER_END_ADDR){
    STM_EVAL_LEDOn(LED6);
    if (FLASH_ProgramWord(Address, DATA_32) == FLASH_COMPLETE) {
    Address = Address + 4;
    }
    else{
      /* Error occurred while writing data in Flash memory. 
         User can add here some code to deal with this error */
    }
    STM_EVAL_LEDOff(LED6);
  } printf("\r\n Write complete \r\n");


- 7 FLASH_LOCK
- 8 GREEN LED OFF

::

  FLASH_Lock(); 
  STM_EVAL_LEDOff(LED4);
  printf("\r\n FLASH lock \r\n");

- 9 VERIFICATION

::

  printf("\r\n FLASH is reading... \r\n");
    while (Address < FLASH_USER_END_ADDR){
    STM_EVAL_LEDOn(LED3);
    data32 = *(__IO uint32_t*)Address;
    
    if (data32 != DATA_32){
     
    /* Error occurred while reading data in Flash memory. 
       User can add here some code to deal with this error */
    }
    Address = FLASH_USER_END_ADDR;
    STM_EVAL_LEDOff(LED3);
  } printf("\r\n Read complete \r\n");


- 10 PRINT DATA_32

::

   printf("\r\n FLASH_USER_END_ADDR  :%d\r\n", *x);


   


6.STM32F407VG 硬體介紹
=====================

- STM32F407VG版子外觀與模組如下圖所示：

.. image:: /STM32F4_2.jpg

- 上方USB Programmer/Debugger為ST-Link
- 石英晶體震盪器(Crystal)，可參考(http://zh.wikipedia.org/zh-tw/%E7%9F%B3%E8%8B%B1%E6%99%B6%E4%BD%93%E8%B0%90%E6%8C%AF%E5%99%A8)
- 中央的晶片為ARM® Cortex™-M4F core with embedded Flash and SRAM，其內部結構如Figure 5所示。
- 三軸加速度感知器(3-axis Accelerometer)
- 音頻數位類比轉換(Audio DAC)
- 麥克風晶片(Chip Microphone)
- USB On The Go (http://forum.slime.com.tw/thread180246.html)
- 音效輸出(Audio Jack)
- 此外，板子上有兩顆按鈕，藍色按鈕為User Button，黑色按鈕為Reset。

.. image:: /block_diag_1.JPG

.. image:: /block_diag_2.JPG
   DM00037051-datasheet P.18


7.reference
===========

- http://wiki.csie.ncku.edu.tw/embedded/learn-stm32-part-1.pdf
- http://wiki.csie.ncku.edu.tw/embedded/learn-stm32-part-6.pdf
- http://www.triplespark.net/elec/pdev/arm/stm32.html
- http://www.codeproject.com/Articles/14983/Remote-Debugging-using-GDB
- http://cms.mcuapps.com/products/stm32f4-discovery/README.html
- http://cms.mcuapps.com/techinfo/toolchains/openocd/
- http://www.st.com/internet/mcu/product/252140.jsp
- http://zh.wikipedia.org/wiki/%E9%97%AA%E5%AD%98
- `快閃記憶體(wiki)<http://zh.wikipedia.org/wiki/%E5%BF%AB%E9%96%83%E8%A8%98%E6%86%B6%E9%AB%94>`_
- http://www.eetasia.com/ART_8800627935_480200_NT_1866240e.HTM
- http://www.xuan.idv.tw/wordpress/?p=821
- `Nand Flash 基本介紹 <http://cmchao.logdown.com/posts/60216>`_
- `Nand Flash BBT Support in Linux  <http://cmchao.logdown.com/posts/61616-nand-flash-support-in-linux>`_