---
title: Lab38: ARM Environment
toc: no
...

預期目標
------------
- 驗證 `Introduction to ARM Architecture<https://docs.google.com/presentation/d/1cFBRICktpVQAOLzE5eDKD-OM4ckJuncFsn39Wg8aLZI/edit#slide=id.p14>`_  簡報內容
- 學習 GNU Toolchain
- 使用 QEMU 作為指令集模擬器

預先準備動作
-------------------
* 在自己的電腦中，安裝 `Lubuntu<http://lubuntu.net/>`_ 14.10 作業系統 (版本太舊的話，後續操作可能會失敗)
  - 虛擬機器環境 (不建議): `透過 VirtualBox 安裝 LubVirtualBox 安裝 Lubuntu<https://hackpad.com/VirtualBox-with-LUbuntu14.04-yza4C1MPF5s>`_

* 安裝相關開發工具

.. code-block:: prettyprint

    sudo apt-get update
    sudo apt-get install build-essential git-core
    sudo apt-get install gcc-arm-linux-gnueabihf g++-arm-linux-gnueabihf
    sudo apt-get install qemu-user qemu-system-arm

* 使用 bash 作為 shell，避免不相容的狀況

.. code-block:: prettyprint

    sudo apt-get install bash

* 關於 GNU/Linux 指令，請參閱 `鳥哥的 Linux 私房菜<http://linux.vbird.org/>`_
  - 本系列課程全程使用 GNU/Linux，全世界有十幾億台裝置內建 Linux 系統，學習 Linux 是相當划算的投資！

範例程式碼操作
---------------------
* 取得 `Introduction to ARM Architecture<https://docs.google.com/presentation/d/1cFBRICktpVQAOLzE5eDKD-OM4ckJuncFsn39Wg8aLZI/edit#slide=id.p14>`_ 簡報對應的程式碼

.. code-block:: prettyprint

        git clone https://github.com/embedded2015/arm-lecture.git

* 確認 `arm-lecture<https://github.com/embedded2015/arm-lecture.git>`_ 目錄已正確由 git 建立，接著切換工作目錄

.. code-block:: prettyprint

    cd arm-lecture

* 試著編譯 ARM 版本的 "Hello World" 程式

.. code-block:: prettyprint

    cd arm-lecture
    cd hello && make qemu

  - 預期將看到以下輸出

.. code-block:: prettyprint

    arm-linux-gnueabihf-as -c  -o hello.o hello.s
    arm-linux-gnueabihf-ld  -o hello hello.o 
    qemu-arm ./hello
    Hello, world!

* 若沒有特別指明，後續操作都在 `arm-lecture<https://github.com/embedded2015/arm-lecture.git>`_ 目錄之下，以下指令可以從 ``hello`` 目錄返回

.. code-block:: prettyprint

    cd ..

對照測試簡報中的範例程式碼
---------------------------------------
* 參閱 `Introduction to ARM Architecture<https://docs.google.com/presentation/d/1cFBRICktpVQAOLzE5eDKD-OM4ckJuncFsn39Wg8aLZI/edit#slide=id.p14>`_ 簡報內容
* Example 1 (Page 31)

.. code-block:: prettyprint

    cd example1
    make default qemu

  - 預期輸出: ``0``
  - 修改  ``example1.c``，將其中的 ``return 0`` 改為 ``return c``，之後再 ``make qemu``，即可知道 ``add(a,b)`` 的輸出結果

* Example 2 (Page 34)

.. code-block:: prettyprint

    cd example2
    make default qemu

  - 預期輸出:

.. code-block:: prettyprint

    a * b is 140
    a * b + c is 143
    c - a * b is -137

  - 對照簡報 Page 40-41，在 Makefile 的 ``CFLAGS`` 加上`` -mcpu=cortex-a15``，可發現生成的 ARM 機械碼使用了 ``sdiv`` 指令

* Example 3 (Page 45)

.. code-block:: prettyprint

    cd example3
    make default qemu

  - 預期輸出

.. code-block:: prettyprint
    a/2 / b/2 is 0

* Example 4 (Page 50)

.. code-block:: prettyprint

    cd example4
    make default qemu

  - 預期輸出

.. code-block:: prettyprint

    a * b is 664237569

* Example 5 (Page 55)

.. code-block:: prettyprint

    cd example5
    make default qemu

  - 預期輸出

.. code-block:: prettyprint

    a & b is 17
    Before operation, apsr was 20030010
    After operation, apsr was 60030010

* Example 6 (Page 62)

.. code-block:: prettyprint

    cd example6
    make default qemu

  - 預期輸出

.. code-block:: prettyprint

    The address of a is 0xf6fff0ac
    The value of b is now 10