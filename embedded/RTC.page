Introduction
==============

Real-Time Clock(RTC)是負責記錄時間的元件，出現在需要長期使用時鐘的電子設備中。例如學校定時關閉冷氣的裝置，以及手機上的鬧鈴功能。

System Overview
----------------- 

基本上RTC（Real-time clock）本身就是一個真正的時鐘，利用原本STM本身所內建的振盪器再利用Prescaler降成1Hz讓RTC使用。利用硬體達成的binary-coded decimal (BCD) format，可以把下列與時間有關的資訊儲存，而且不需要任何軟體轉換，因為硬體就已經把資料轉成一般的日期格式。

- sub-seconds 
- seconds
- minutes
- hours in 12-hour or 24-hour format
- day of the week (day)
- day of the month (date)
- month
- year

可用的功能

- Alarm A ＆ Alarm B
- Auto wakeup
- Timestamp
- Tamper detection


Block Diagram  
--------------------

.. image:: /rtc_block.png





Functional Description
============================
Clock Source 
--------------------

.. image:: /clocksource2.png

**STM32的 Clock 有分成「SYSCLK」和「RTCCLK」：**

SYSCLK為系統的clock有三種來源：

1. **HSI**  (High-Speed Internal) ：16MHz,RC電路
2. **HSE** (Low-Speed External)：4-26MHz (一般選用8MHz),石英震盪
3. Main **PLL** clock

RTCCLK為設備的clock有兩種來源：

1. **LSI**  (Low-Speed Internal)  ：40kHz,RC電路震盪
2. **LSE** (High-Speed External)：32.768kHz,石英震盪

----> RTC 主要是使用 **HSE** , **LSI**  , **LSE** 三種來源

*參閱reference manual p.150*

-----------------------------------------------

**比較 「HSE」, 「LSI」 , 「LSE」三種輸入來源：** 


- HSE  -  較為耗能， 可以處理像是USB或TV訊號的clock，需要和和另一個clock穩定同步。
- LSI  -  是一個低功耗的clock，可以再停機或待機模式下保持運行，用在auto-wakeup(簡稱AWU)與 watchdog看門狗(簡稱IMDG)。
- LSE  -  它是一個低功耗且"精準"的clock，適合用在時間的精確計算。

Prescaler 
--------------------
.. image:: /RTC_Prescalers.png

``ck_spre``一般而言要降為1Hz的頻率，因為省電的因素STM設計了兩個Prescaler。7 bit非同步prescaler(``PREDIV_A``)和15 bit同步的prescaler(``PREDIV_S``)。這兩個prescaler要在RTC_PRER的暫存器設定。*ST在Reference有說明當兩個Prescaler都使用時，建議讓非同步的Prescaler讓他有較大的值，以讓系統更省電*

所以``ck_spre``與兩個prescaler的關係為:

.. image:: /ck_spre2.png


例如:

LSE: 32.768kHz / (127+1) / (255+1) = 1Hz

LSI: 32kHz / (127+1) /(249+1) =1Hz

Alternate Function RTC Outputs
--------------------------------------

Alternate function 可以將RTC某些功能對應到輸出的接腳(GPIO Pin)，這些輸出可以被選擇成**tamp event** 或 **time stamp event**，

甚至RTC Calibration 的訊號都可以藉由這個功能輸出。

可以選擇兩個輸出:

輸出接腳 **RTC_AF1(PC13)** : 

- RTC_ALARM output:    1. RTC Alarm A       2. RTC Alarm B       3. RTC Wakeup

- RTC_CALIB output

- RTC_TAMP1

- RTC_TS

輸出接腳 **RTC_AF2 (PI8)** :

- RTC_TAMP1

- RTC_TAMP2

- RTC_TS

*Reference Manual p.277*

*PI8接腳參考: datasheet p.10*

RTC Calendar 
--------------------


.. image:: /RTC_calendar.png


**讀取Calendar**


當在讀取Calendar時其實並不是真正直接讀取calendar register，其實是讀**shadow register**，

如果想要直接讀取calendar必須要設``BYPSHAD`` 控制位元為1(在``RTC_CR`` register)才能繞過shadow register

而直接讀取calender register，通常初始化和讀取的動作採用Shadow Register。

-----------------------------

Calibration
-----------------------------

RTC裡面有兩個校正功能，一個是RTC coarse calibration另一個是RTC smooth calibration。

**1、RTC coarse calibration ：**

- coarse calibration 被使用在補償石英震盪器的校正。

- 在非同步分頻器(ck_apre)的輸出，藉由增加或減少時間的週期達到校正，最大範圍的校正為63ppm~126ppm。

- 可以使用AFO_CALIB來計算時間偏差，並更新calibration方塊圖的1Hz(ck_apre)輸出。

- 在512Hz時,並不能去檢查校正結果，只能檢查經過calibration方塊圖的1Hz(ck_apre)輸出。

- 完整的校正週期要持續64分鐘。

- 只能在初始化Calendar時候修改，不能在RTC開啟的時候修改。導致不可校正動態的誤差，只能校正固定的誤差，是一個非回授控制系統(opened loop control)。　

- reference clock calibration 和 coarse calibration 不能同時使用。


.. image:: /coarse cal.png

**2、RTC  smooth calibration：**

- smooth calibration 利用每個RTCCLK pulse為單位做出小幅調整，來修正RTC的clock頻率。

- 最大範圍的校正為-487.1ppm~+488.5ppm。 

- smooth calibration 可以補償石英震盪器的偏差，此偏差可能是晶體老化或者溫度所造成。

- 可以使用AFO_CALIB來計算時間偏差，而且可直接檢查512Hz和1Hz的校正輸出。

- 可使用RTC_CALR register裡面的CALP和CALM去增加或減少pulses。 

- smooth calibration可配置8秒、16秒、32秒的校正視窗，沒設定的情況下為32秒的視窗。

- 與coarse calibration不同，可藉由AFO_CALIB得到時鐘的偏差值(clock deviation)。這種方法可以確認修正的結果，是一個閉迴路的控制系統(closed loop control)。

- smooth calibration可以使用在：

      1.AFO_CALIB (512 Hz or 1 Hz)。 　2.sub-second alarms。　 3.Wakeup timer。

.. image:: /smooth cal.png

**3、RTC reference clock detection：**

- 利用外部時鐘校正，其時鐘源要比LSE的時鐘還精準。

*原文:The reference clock (at 50 Hz or 60 Hz) should have a higher precision than the 32.768 kHz LSE clock.*

---------------------------------------------------


Low Power Modes
--------------------

- RTC 設計為最小的耗能，在休眠模式下，RTC將繼續動作。

- 當clock 的來源是LSE 或 LSI，在停止模式與待機模式下，RTC仍然活躍的動作。

- 在低功率( low power mode)模式下，Alarm, tamper event, time stamp event, and wakeup 依然會被中斷所啟動。

.. image:: /RTC in low power mode.png

---------------------------------------------------

---------------------------------------------------


Interrupt Application
==========================

Alarm
---------------------------

calendar register與alarm作比較，如果相同則將對應的flag拉起來。

.. image:: /embedded/RTC/alarm_pass.png

---------------------------

Periodic Wakeup Unit
----------------------------

Time-stamp Function
--------------------------

Tamper Detection Function
---------------------------------


Example of code
========================

Initialize RTC
--------------------

.. code-block:: prettyprint
	
    RTC_InitTypeDef RTC_InitStructure;
	
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);   /* Enable the PWR clock */
    PWR_BackupAccessCmd(ENABLE);                          /* Allow access to RTC */

    RCC_LSICmd(ENABLE);                                   /* Enable the LSI OSC */
    while(RCC_GetFlagStatus(RCC_FLAG_LSIRDY) == RESET);   /* Wait till LSI is ready */  
    RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);               /* Select the RTC Clock Source */
	
    RCC_RTCCLKCmd(ENABLE);                                /* Enable the RTC Clock */
    RTC_WaitForSynchro();                                 /* Wait for RTC APB registers synchronisation */

    /* Configure the RTC data register and RTC prescaler */
    RTC_InitStructure.RTC_AsynchPrediv = 0x7F;
    RTC_InitStructure.RTC_SynchPrediv = 0xF9;
    RTC_InitStructure.RTC_HourFormat = RTC_HourFormat_24;
    RTC_Init(&RTC_InitStructure);

setting time
--------------------

.. code-block:: prettyprint

	/* set 8:29:55 */
	RTC_TimeTypeDef RTC_TimeStruct;
	RTC_TimeStruct.RTC_Hours = 8;
	RTC_TimeStruct.RTC_Minutes = 29;
	RTC_TimeStruct.RTC_Seconds = 55;
	
	RTC_SetTime(RTC_Format_BIN, &RTC_TimeStruct);


initialize RTC alarm
--------------------

.. code-block:: prettyprint

	EXTI_InitTypeDef EXTI_InitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;

	/* EXTI configuration */
	EXTI_ClearITPendingBit(EXTI_Line17);
	EXTI_InitStructure.EXTI_Line = EXTI_Line17;
	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
	EXTI_Init(&EXTI_InitStructure);

	/* Enable the RTC Alarm Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = RTC_Alarm_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);


setting alarm time
--------------------

.. code-block:: prettyprint

	RTC_AlarmTypeDef RTC_AlarmStructure;

	RTC_AlarmCmd(RTC_Alarm_A, DISABLE);   /* disable before setting or cann't write */

	/* set alarm time 8:30:0 everyday */
	RTC_AlarmStructure.RTC_AlarmTime.RTC_H12     = 0x00;
	RTC_AlarmStructure.RTC_AlarmTime.RTC_Hours   = 8;
	RTC_AlarmStructure.RTC_AlarmTime.RTC_Minutes = 30;
	RTC_AlarmStructure.RTC_AlarmTime.RTC_Seconds = 0;
	RTC_AlarmStructure.RTC_AlarmDateWeekDay = 0x31; // Nonspecific
	RTC_AlarmStructure.RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
	RTC_AlarmStructure.RTC_AlarmMask = RTC_AlarmMask_DateWeekDay; // Everyday 
	RTC_SetAlarm(RTC_Format_BIN, RTC_Alarm_A, &RTC_AlarmStructure);
	
	/* Enable Alarm */
	RTC_ITConfig(RTC_IT_ALRA, ENABLE);
	RTC_AlarmCmd(RTC_Alarm_A, ENABLE);
	RTC_ClearFlag(RTC_FLAG_ALRAF);



complete code
--------------------

.. code-block:: c

    git clone git@gitcafe.com:ctc8631/RTC-example.git
    cd RTC-example/
    make flash



Previous
=============

Generate 1Hz
--------------------
http://wiki.csie.ncku.edu.tw/embedded/RTC
RTC基本計算單位為一秒鐘。

由於clock source速度太快，我們需要用prescaler去轉換成一秒鐘。

.. image:: /stm32 RTC prescaler.png

基於省電需求，將prescaler分為兩個區塊，首先經由較省電的Asynchronous prescaler，再透過較耗能量的Synchronous prescaler輸出1Hz。

根據clock source的頻率不同，我們調整不同的prescaler參數。


.. image:: /embedded/RTC/ck_spre_formula.png

LSE: 32.768kHz / (127+1) / (255+1) = 1Hz

LSI: 32kHz / (127+1) /(249+1) =1Hz



Previous Functionality
-------------------------





Prescaler
----------
Prescaler generates the clock to update the calendar.

To minimize power comsuption the prescaler is split into two prescalers, asynchronous and synchronous. It is recommended to configure the asynchronous prescaler to a high value to minimize consumption.

asynchronous prescaler clocks subsecond of calendar and propagates to synchronous prescaler to update date and time by second.

One can configure them through ``PREDIV_A`` and ``PREDIV_S`` bits in ``RTC_PRER``


Calendar and Alarm
--------------------
A calendar keeps track of the date (day, week, month, year) and time (hours, minutes and seconds) and even subseconds. It manages of numbers of days of mouths automaticly. Daylight saving time adjustment is programmable by software.

Binary repersentation is in binary-coded decimal (BCD) format. 

Data can be read indirectly from shadow registers or directly from counters. The former method delays some clocks but ensures consistency between date and time registers; the later is opposite but this is especially useful after exiting from low power modes, since the shadow registers are not updated during these modes.

Data, time, and subsecond are separately recorded in ``RTC_DR``, ``RTC_TR``, and ``RTC_SSR``. With ``BYPSHAD`` bit set, data can be read directly from counter.

Two programmable alarms (Alarm A, Alarm B) with **interrupt function**. The alarms can be triggered by any **combination** of the calendar fields.

An alarm consists of a register with the same length as the RTC time counter. When the RTC time counter reaches the value programmed in the alarm register, a flag is set to indicate that an alarm event occurred.

In addition to the time to trigger, alarm can be configured to mask some fields and do not compare.


Auto periodic wakeup
------------------------------
A periodic timebase and wakeup unit that can wake up the system from low power modes. When this counter reaches zero, a flag and an interrupt are generated.

It's source clock can be RTC clock or prescaler. Time range can be configured through ``WUCKSEL``


Timestamp
----------
The calendar is saved in timestamp registers when timestamp event is detected on the pin which timestamp alternate function is mapped.


Tamper detection
--------------------
It can be used for edge detection or level detection with filtering according to ``TAMPFLT``. Set to 00 is edge detection, others arg level detection.

When ``TAMPTS`` set to 1, tamper event trigger timestamp event automatically.


Backup registers
--------------------
Program can read or write data from or to these registers, which are not reset by system reset or power-on reset. They are  reset when tamper detection event occurs.


Alternate function outputs
------------------------------
Two outputs are avalible : ``RTC_CALIB`` and ``RTC_ALARM``.

``RTC_CALIB`` output is used to generate a variable-frequency signal. It can use either asynchronous or synchronous prescaler as clock.

besides alarm, ``RTC_ALARM`` can use wakeup timer as source.


Synchronization and Reference clock detection
--------------------------------------------------
RTC can be synchronized to remote clock by adding a 'shift' to counter continuously to delay, or vice versa. 
With reference clock detection, RTC shifts misaligned 1 Hz clock to align it with the nearst referenced edge (found in a given time window).

One can adjust time by configuring shift through ``RTC_SHIFTR``.

When reference clock detection is enabled (``REFCKON``), must not write ``RTC_SHIFTR`` and not enable calibration and set prescalers (``PREDIV_A`` and ``PREDIV_S``) to default.


Digital calibration
--------------------
Calibration can be used to compensate inaccuracy of oscillator by adding or substracting clock cycles in each calibration cycle.

There are two calibration methods : coarse and smooth. They should not be used togather. The cycle of the later is smaller than the former. It makes the later is more flexible to adjust clock. A smooth calibration can be performed on the fly so that it can be changed to handle changed envirenment variables.

coarse calibration is provided for capability reasons. It can only be configured in initialization mode and start when INIT bit is cleared. Also it is recommaned using it for static correction only.






Previous Configuration  Register write protection
-------------------------------------------------------
After system **reset**, the RTC registers are protected registers are automatically locked to against **possible parasitic write accesses**.

RTC registers need to **disable** backup domain protection to update the current calendar time and date.

    set ``DBP`` bit in ``PWR_CR``

After power-up reset, the RTC registers are also protected and need to write a key into protection register. RTC_ISR[13:8], RTC_TAFCR, and RTC_BKPxR are except. Write a wrong key will enable protection.

    write ``0xCA`` to ``RTC_WPR``

    write ``0x53`` to ``RTC_WPR``

Initialization mode
--------------------
Modifications of ``RTC_DR``, ``RTC_TR``, and ``RTC_PRER`` must be done in Initialization mode.

    set ``INIT`` bit of ``RTC_ISR`` to enter Initialization mode

    wait until ``RTC_ISR`` / ``INITF`` is set then ready to write

    reset ``INIT`` bit of ``RTC_ISR`` to exit Initialization mode

Counter does not run in Initialization mode.

Reference
================
`RTC application note<http://www.st.com/st-web-ui/static/active/cn/resource/technical/document/application_note/DM00025071.pdf>`_

`STM32F405xx/07xx, STM32F415xx/17xx, STM32F42xxx and STM32F43xxx Reference Manual
<http://www.st.com/st-web-ui/static/active/en/resource/technical/document/reference_manual/DM00031020.pdf>`_

`共筆<https://hackpad.com/STM32F74-RTCReal-Time-Clock-eclVxLGTj50>`_