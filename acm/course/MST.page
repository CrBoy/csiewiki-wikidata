#MST (Minimum Spanning Tree, æœ€å°ç”Ÿæˆæ¨¹)
##Spanning Tree (ç”Ÿæˆæ¨¹)
1. ä¸€æ£µ<b>åŒ…å«åœ–ä¸Šæ‰€æœ‰é»</b>çš„æ¨¹ï¼Œç¨±ä½œè©²åœ–çš„<b>ç”Ÿæˆæ¨¹</b>

2. ä¸€å¼µåœ–çš„ç”Ÿæˆæ¨¹å¯èƒ½æœƒæœ‰å¾ˆå¤šç¨®

3. <b>å®Œå…¨é€£é€šåœ–</b>æ‰æœ‰ç”Ÿæˆæ¨¹ (ä¸é€£é€šæ™‚ï¼Œå‰‡ç¨±ç‚ºç”Ÿæˆæ£®æ—)

4. ç”Ÿæˆæ¨¹çš„æ¬Šé‡ç‚ºæ¨¹ä¸Šæ¯æ¢é‚Šçš„æ¬Šé‡ç¸½å’Œ

##Minimum Spanning Tree
æ“æœ‰<b>æœ€å°æ¬Šé‡</b>çš„ç”Ÿæˆæ¨¹ï¼Œç¨±ç‚ºæœ€å°ç”Ÿæˆæ¨¹

###Kruskalâ€™s Algorithm (greedy based)
1. ä¾ç…§æ¬Šé‡æ’åº

2. é¸æ“‡è¼ƒå°çš„é‚Šï¼Œä¸¦æª¢æŸ¥æ˜¯å¦æœ‰ç’°

* Psuedocode
```c++
KRUSKAL(G):
 A = âˆ…
 foreach v âˆˆ G.V:
    MAKE-SET(v)
 foreach (u, v) in G.E ordered by weight(u, v), increasing:
    if FIND-SET(u) â‰  FIND-SET(v):
       A = A âˆª {(u, v)}
       UNION(u, v)
 return A
```

![](/acm/MST_Kruskal.gif)

```c++
const int V = 100, E = 1000;	// V = vertice, E = edge
 
struct Edge{int a, b, c;} e[E];    // edge list
bool operator<(const Edge& e1, const Edge& e2){ return e1.c < e2.c;}
 
// disjoint-sets forest
int p[V];
int init(){ for(int i=0; i<V; ++i)	p[i] = i;}
int find(int x){ return x == p[x] ? x : (p[x] = find(p[x]));}
void union(int x, int y){ p[find(x)] = find(y);}
 
void Kruskal(){
    init();
    sort(edge, edge+E);		// åœ–ä¸Šæ‰€æœ‰é‚Šï¼Œä¾ç…§æ¬Šé‡å¤§å°ï¼Œç”±å°åˆ°å¤§æ’åºã€‚O(NlogN)
 
    for(int j = 0; i < V-1 && j < E; j ++){	// çª®èˆ‰åœ–ä¸Šæ‰€æœ‰é‚Šï¼Œå˜—è©¦ä½œç‚ºæœ€å°ç”Ÿæˆæ¨¹ï¼ˆæ£®æ—ï¼‰
        if(find(e[j].a) == find(e[j].b))	// ç”¢ç”Ÿç’°ï¼Œå‰‡æ¨æ£„ã€‚
		continue;
        union(e[j].a, e[j].b);	// ç”¢ç”Ÿæ©‹ï¼Œå‰‡ä»¥æ­¤é‚Šé€£æ¥å…©æ£µMSSã€‚
    }
}
```
* æ™‚é–“è¤‡é›œåº¦ O(ElgE)

###Primâ€™s Algorithm (relaxation based)
1.æ‰€æœ‰ç¯€é»è¨­ç‚º<b>æœªæ‹œè¨ª</b>é (è¨­ç‚ºINF)

2.ä»¤d[i]ç‚ºåˆ°ç¯€é»içš„è·é›¢(æ¯æ¬¡çš†è€ƒæ…®é„°è¿‘ç¯€é»)

3.è€ƒæ…®æ‰€æœ‰é„°è¿‘<b>æ¨¹</b>ä¸”<b>æœªæ‹œè¨ªé</b>çš„ç¯€é»iï¼Œé¸æ“‡è·é›¢æœ€è¿‘çš„ç¯€é»ï¼Œä¸¦æª¢æŸ¥æ˜¯å¦æœ‰ç’°

4.æ›´æ–°æ‹œè¨ªéç¯€é»èˆ‡é„°è¿‘ç¯€é»d[i]

![](/acm/MST_Prim.gif)

```c++
int w[9][9];    // adjacency matrix
int d[9];       // ç´€éŒ„ç›®å‰çš„MSTåˆ°åœ–ä¸Šå„é»çš„è·é›¢
int parent[9];  // ç´€éŒ„å„å€‹é»åœ¨MSTä¸Šçš„çˆ¶è¦ªæ˜¯èª°
bool visit[9];  // ç´€éŒ„å„å€‹é»æ˜¯ä¸æ˜¯å·²åœ¨MSTä¹‹ä¸­
 
void prim(){
    for(int i=0; i<9; i++)	visit[i] = false;
    for(int i=0; i<9; i++)	d[i] = 1e9;
 
    d[0] = 0;   // å¯ä»¥é¸å®šä»»ä½•é»ä½œç‚ºæ¨¹æ ¹ï¼Œé€™è£¡ä»¥ç¬¬é›¶é»ä½œç‚ºæ¨¹æ ¹ã€‚
    parent[0] = 0;
 
    for(int i=0; i<9; i++){
        int a = -1, b = -1, min = 1e9;
        for(int j=0; j<9; j++)
            if(!visit[j] && d[j] < min){
                a = j;  // è¨˜éŒ„é€™ä¸€æ¢é‚Š
                min = d[j];
            }
 
        if(a == -1)	break; // èˆ‡èµ·é»ç›¸é€£é€šçš„MSTéƒ½å·²æ‰¾å®Œ
        visit[a] = true;
//      d[a] = 0;           // è¨»è§£å¾Œï¼Œå¾—åˆ°MSTæ¯æ¢é‚Šæ¬Šé‡ã€‚
 
        for(b=0; b<9; b++)
            if(!visit[b] && w[a][b] < d[b]){
                d[b] = w[a][b]; // é›¢æ¨¹æœ€è¿‘ï¼Œä¸æ˜¯é›¢æ ¹æœ€è¿‘ã€‚
                parent[b] = a;
            }
    }
}
```

* æ™‚é–“è¤‡é›œåº¦ O(ğ‘‰")

 With Binary-Heap : O( (V+E)logV)

åƒè€ƒä¾†æºï¼š

æ¼”ç®—æ³•ç­†è¨˜ http://www.csie.ntnu.edu.tw/~u91029/SpanningTree.html

ç¶­åŸºç™¾ç§‘ https://en.wikipedia.org/wiki/Kruskal%27s_algorithm