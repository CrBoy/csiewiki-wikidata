#MST (Minimum Spanning Tree, æœ€å°ç”Ÿæˆæ¨¹)
##Spanning Tree (ç”Ÿæˆæ¨¹)
1. ä¸€æ£µ<b>åŒ…å«åœ–ä¸Šæ‰€æœ‰é»</b>çš„æ¨¹ï¼Œç¨±ä½œè©²åœ–çš„<b>ç”Ÿæˆæ¨¹</b>

2. ä¸€å¼µåœ–çš„ç”Ÿæˆæ¨¹å¯èƒ½æœƒæœ‰å¾ˆå¤šç¨®

3. <b>å®Œå…¨é€£é€šåœ–</b>æ‰æœ‰ç”Ÿæˆæ¨¹ (ä¸é€£é€šæ™‚ï¼Œå‰‡ç¨±ç‚ºç”Ÿæˆæ£®æ—)

4. ç”Ÿæˆæ¨¹çš„æ¬Šé‡ç‚ºæ¨¹ä¸Šæ¯æ¢é‚Šçš„æ¬Šé‡ç¸½å’Œ

##Minimum Spanning Tree
æ“æœ‰<b>æœ€å°æ¬Šé‡</b>çš„ç”Ÿæˆæ¨¹ï¼Œç¨±ç‚ºæœ€å°ç”Ÿæˆæ¨¹

###Kruskalâ€™s algorithm (greedy based)
1. ä¾ç…§æ¬Šé‡æ’åº

2. é¸æ“‡è¼ƒå°çš„é‚Šï¼Œä¸¦é‚Šæª¢æŸ¥æ˜¯å¦æœ‰è¿´åœˆ

![](/acm/MST_Kruskal.gif)

* Psuedocode

        totalcostâ† 0 
        for each v âˆˆ V
            do MAKE-SET (v)
        sort the edges into non-decreasing order by weight
        for each edge (u, v) âˆˆ E, taken in non-decreasing order
            do if FIND-SET (u) â‰  FIND-SET (v)
                then UNION (u, v) 
                    totalcostâ† totalcost+ w(u, v)
        return totalcost
    * æ™‚é–“è¤‡é›œåº¦ O(ElgE)

###Primâ€™s algorithm (relaxation based)
1. æ‰€æœ‰ç¯€é»è¨­ç‚º<b>æœªæ‹œè¨ª</b>é

2. ä»¤d[i]ç‚ºåˆ°ç¯€é»içš„ç›®å‰è·é›¢ï¼Œèµ·ä½¿çš†è¨­ç‚ºINF

3. æ¯æ¬¡éƒ½å»æ‰¾æœªæ‹œè¨ªéçš„ç¯€é»iï¼Œè€Œä¸”d[i]æœ€å°

4. æ‰¾å®Œå¾Œè¦æ›´æ–°æœªæ‹œè¨ªéçš„ç¯€é»è·é›¢d[j] ( if(æ‰¾åˆ°çš„ç¯€é»iåˆ°ç¯€é»jçš„è·é›¢<d[j])  å‰‡æ›´æ–°d[j] )

![](/acm/MST_Prim.gif)

```c++
#include <cstdio>
using namespace std;
int main()
{
}
```

*æ™‚é–“è¤‡é›œåº¦ O(ğ‘‰")

 With Binary-Heap : O( (V+E) lgV)


åƒè€ƒä¾†æºï¼šæ¼”ç®—æ³•ç­†è¨˜ http://www.csie.ntnu.edu.tw/~u91029/SpanningTree.html#2